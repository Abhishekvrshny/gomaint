
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gin-service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/abhishekvarshney/gomaint/examples/gin-service/main.go (0.0%)</option>
				
				<option value="file1">github.com/abhishekvarshney/gomaint/examples/gorm-service/main.go (0.0%)</option>
				
				<option value="file2">github.com/abhishekvarshney/gomaint/examples/grpc-service/client/client.go (0.0%)</option>
				
				<option value="file3">github.com/abhishekvarshney/gomaint/examples/grpc-service/cmd/healthcheck/main.go (0.0%)</option>
				
				<option value="file4">github.com/abhishekvarshney/gomaint/examples/grpc-service/main.go (0.0%)</option>
				
				<option value="file5">github.com/abhishekvarshney/gomaint/examples/grpc-service/proto/user.pb.go (0.0%)</option>
				
				<option value="file6">github.com/abhishekvarshney/gomaint/examples/grpc-service/proto/user_grpc.pb.go (0.0%)</option>
				
				<option value="file7">github.com/abhishekvarshney/gomaint/examples/grpc-service/server/user_service.go (0.0%)</option>
				
				<option value="file8">github.com/abhishekvarshney/gomaint/examples/http-service/main.go (0.0%)</option>
				
				<option value="file9">github.com/abhishekvarshney/gomaint/examples/kafka-service/main.go (0.0%)</option>
				
				<option value="file10">github.com/abhishekvarshney/gomaint/examples/sqs-service/main.go (0.0%)</option>
				
				<option value="file11">github.com/abhishekvarshney/gomaint/examples/xorm-service/main.go (0.0%)</option>
				
				<option value="file12">github.com/abhishekvarshney/gomaint/gomaint.go (0.0%)</option>
				
				<option value="file13">github.com/abhishekvarshney/gomaint/pkg/eventsource/etcd.go (14.4%)</option>
				
				<option value="file14">github.com/abhishekvarshney/gomaint/pkg/handlers/database/database.go (0.0%)</option>
				
				<option value="file15">github.com/abhishekvarshney/gomaint/pkg/handlers/grpc/grpc.go (0.0%)</option>
				
				<option value="file16">github.com/abhishekvarshney/gomaint/pkg/handlers/handler.go (0.0%)</option>
				
				<option value="file17">github.com/abhishekvarshney/gomaint/pkg/handlers/http/http.go (0.0%)</option>
				
				<option value="file18">github.com/abhishekvarshney/gomaint/pkg/handlers/kafka/kafka.go (0.0%)</option>
				
				<option value="file19">github.com/abhishekvarshney/gomaint/pkg/handlers/sqs/sqs.go (0.0%)</option>
				
				<option value="file20">github.com/abhishekvarshney/gomaint/pkg/logger/logger.go (100.0%)</option>
				
				<option value="file21">github.com/abhishekvarshney/gomaint/pkg/maintenance/manager.go (0.0%)</option>
				
				<option value="file22">github.com/abhishekvarshney/gomaint/pkg/set/set.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"

        "github.com/abhishekvarshney/gomaint"
        httpHandler "github.com/abhishekvarshney/gomaint/pkg/handlers/http"
)

const (
        defaultPort         = "8080"
        defaultEtcdKey      = "/maintenance/gin-service"
        defaultEtcdEndpoint = "localhost:2379"
        defaultDrainTimeout = 30 * time.Second
)

// User represents a user in our API
type User struct {
        ID       int       `json:"id"`
        Name     string    `json:"name"`
        Email    string    `json:"email"`
        Username string    `json:"username"`
        Created  time.Time `json:"created"`
}

// App holds the application dependencies
type App struct {
        ginEngine *gin.Engine
        server    *http.Server
        manager   *gomaint.Manager
        users     []User // In-memory store for demo
}

func main() <span class="cov0" title="0">{
        fmt.Println("Gin Service with Maintenance Mode")
        fmt.Println("=================================")

        app, err := setupApp()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to setup application: %v", err)
        }</span>

        // Setup graceful shutdown
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle shutdown signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                log.Println("Shutting down Gin service...")
                cancel()
        }</span>()

        // Start the application
        <span class="cov0" title="0">if err := app.run(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Application failed: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Application stopped")</span>
}

func setupApp() (*App, error) <span class="cov0" title="0">{
        // Get configuration from environment variables
        port := getEnv("HTTP_PORT", defaultPort)
        etcdEndpoints := getEnv("ETCD_ENDPOINTS", defaultEtcdEndpoint)
        etcdKey := getEnv("ETCD_KEY", defaultEtcdKey)

        // Parse drain timeout
        drainTimeoutStr := getEnv("DRAIN_TIMEOUT", "30s")
        drainTimeout, err := time.ParseDuration(drainTimeoutStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Invalid DRAIN_TIMEOUT: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Gin service starting on port %s", port)
        log.Printf("Drain timeout: %v", drainTimeout)
        log.Printf("etcd endpoints: %s", etcdEndpoints)
        log.Printf("etcd key: %s", etcdKey)

        // Set Gin to release mode if not in development
        if getEnv("GIN_MODE", "release") == "release" </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>

        // Create Gin engine
        <span class="cov0" title="0">ginEngine := gin.New()
        ginEngine.Use(gin.Logger(), gin.Recovery())

        // Create HTTP server
        server := &amp;http.Server{
                Addr:         ":" + port,
                Handler:      ginEngine,
                ReadTimeout:  15 * time.Second,
                WriteTimeout: 15 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        app := &amp;App{
                ginEngine: ginEngine,
                server:    server,
                users: []User{
                        {ID: 1, Name: "Alice Johnson", Email: "alice@example.com", Username: "alice", Created: time.Now().Add(-24 * time.Hour)},
                        {ID: 2, Name: "Bob Smith", Email: "bob@example.com", Username: "bob", Created: time.Now().Add(-12 * time.Hour)},
                        {ID: 3, Name: "Charlie Brown", Email: "charlie@example.com", Username: "charlie", Created: time.Now().Add(-6 * time.Hour)},
                },
        }

        // Setup routes
        app.setupRoutes()

        // Create HTTP handler for maintenance mode
        handler := httpHandler.NewHTTPHandler(server, drainTimeout)

        // Skip health check and metrics endpoints from maintenance mode
        handler.SkipPaths("/health", "/metrics", "/ping")

        // Parse etcd endpoints
        endpoints := strings.Split(etcdEndpoints, ",")

        // Start maintenance manager with etcd
        ctx := context.Background()
        mgr, err := gomaint.StartWithEtcd(ctx, endpoints, etcdKey, drainTimeout, handler)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start maintenance manager: %v", err)
        }</span>

        <span class="cov0" title="0">app.manager = mgr
        return app, nil</span>
}

func (app *App) setupRoutes() <span class="cov0" title="0">{
        // Health endpoints (these will be skipped during maintenance)
        app.ginEngine.GET("/health", app.healthHandler)
        app.ginEngine.GET("/ping", app.pingHandler)
        app.ginEngine.GET("/metrics", app.metricsHandler)

        // API routes
        api := app.ginEngine.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // User endpoints
                users := api.Group("/users")
                </span><span class="cov0" title="0">{
                        users.GET("", app.listUsers)
                        users.POST("", app.createUser)
                        users.GET("/:id", app.getUser)
                        users.PUT("/:id", app.updateUser)
                        users.DELETE("/:id", app.deleteUser)
                }</span>

                // Search endpoints
                <span class="cov0" title="0">api.GET("/search/users", app.searchUsers)

                // Status endpoint
                api.GET("/status", app.statusHandler)</span>
        }

        // Static content
        <span class="cov0" title="0">app.ginEngine.GET("/", app.indexHandler)
        app.ginEngine.GET("/about", app.aboutHandler)</span>
}

func (app *App) run(ctx context.Context) error <span class="cov0" title="0">{
        // Maintenance manager is already started by StartWithEtcd

        // Start HTTP server
        go func() </span><span class="cov0" title="0">{
                log.Printf("Starting Gin HTTP server on %s", app.server.Addr)
                if err := app.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("HTTP server failed: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">log.Println("Gin service started successfully")
        log.Println("Available endpoints:")
        log.Printf("  Main page:        http://localhost:%s/", getEnv("HTTP_PORT", defaultPort))
        log.Printf("  Health check:     http://localhost:%s/health", getEnv("HTTP_PORT", defaultPort))
        log.Printf("  Users API:        http://localhost:%s/api/v1/users", getEnv("HTTP_PORT", defaultPort))
        log.Printf("  Search API:       http://localhost:%s/api/v1/search/users?q=alice", getEnv("HTTP_PORT", defaultPort))
        log.Printf("  Service Status:   http://localhost:%s/api/v1/status", getEnv("HTTP_PORT", defaultPort))
        log.Println()
        log.Println("To enable maintenance mode:")
        log.Printf("  etcdctl put %s true", getEnv("ETCD_KEY", defaultEtcdKey))
        log.Println()
        log.Println("To disable maintenance mode:")
        log.Printf("  etcdctl put %s false", getEnv("ETCD_KEY", defaultEtcdKey))
        log.Println()
        log.Println("Press Ctrl+C to stop...")

        // Wait for context cancellation
        &lt;-ctx.Done()

        // Graceful shutdown
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer shutdownCancel()

        // Stop maintenance manager
        app.manager.Stop()

        // Shutdown HTTP server
        if err := app.server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Printf("HTTP server shutdown error: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">log.Println("Gin service stopped gracefully")
        return nil</span>
}

// Health and status handlers (skipped during maintenance)
func (app *App) healthHandler(c *gin.Context) <span class="cov0" title="0">{
        health := app.manager.GetHandlerHealth()
        allHealthy := true
        for _, healthy := range health </span><span class="cov0" title="0">{
                if !healthy </span><span class="cov0" title="0">{
                        allHealthy = false
                        break</span>
                }
        }

        <span class="cov0" title="0">status := "healthy"
        statusCode := http.StatusOK
        if !allHealthy </span><span class="cov0" title="0">{
                status = "unhealthy"
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, gin.H{
                "status":      status,
                "maintenance": app.manager.IsInMaintenance(),
                "handlers":    health,
                "timestamp":   time.Now().UTC(),
        })</span>
}

func (app *App) pingHandler(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message":   "pong",
                "timestamp": time.Now().UTC(),
        })
}</span>

func (app *App) metricsHandler(c *gin.Context) <span class="cov0" title="0">{
        // Get handler stats
        var httpStats map[string]interface{}
        if handler, exists := app.manager.GetHandler("http"); exists </span><span class="cov0" title="0">{
                if h, ok := handler.(*httpHandler.Handler); ok </span><span class="cov0" title="0">{
                        httpStats = h.GetStats()
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "maintenance": app.manager.IsInMaintenance(),
                "handlers":    app.manager.GetHandlerHealth(),
                "http_stats":  httpStats,
                "users_count": len(app.users),
                "timestamp":   time.Now().UTC(),
        })</span>
}

// API handlers (affected by maintenance mode)
func (app *App) listUsers(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "users": app.users,
                "count": len(app.users),
        })
}</span>

func (app *App) createUser(c *gin.Context) <span class="cov0" title="0">{
        var newUser User
        if err := c.ShouldBindJSON(&amp;newUser); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Simple ID assignment
        <span class="cov0" title="0">newUser.ID = len(app.users) + 1
        newUser.Created = time.Now()
        app.users = append(app.users, newUser)

        c.JSON(http.StatusCreated, gin.H{
                "message": "User created successfully",
                "user":    newUser,
        })</span>
}

func (app *App) getUser(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        for _, user := range app.users </span><span class="cov0" title="0">{
                if fmt.Sprintf("%d", user.ID) == id </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{"user": user})
                        return
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})</span>
}

func (app *App) updateUser(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        for i, user := range app.users </span><span class="cov0" title="0">{
                if fmt.Sprintf("%d", user.ID) == id </span><span class="cov0" title="0">{
                        var updateUser User
                        if err := c.ShouldBindJSON(&amp;updateUser); err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                                return
                        }</span>

                        // Update fields (keep original ID and Created time)
                        <span class="cov0" title="0">updateUser.ID = user.ID
                        updateUser.Created = user.Created
                        app.users[i] = updateUser

                        c.JSON(http.StatusOK, gin.H{
                                "message": "User updated successfully",
                                "user":    updateUser,
                        })
                        return</span>
                }
        }

        <span class="cov0" title="0">c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})</span>
}

func (app *App) deleteUser(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        for i, user := range app.users </span><span class="cov0" title="0">{
                if fmt.Sprintf("%d", user.ID) == id </span><span class="cov0" title="0">{
                        app.users = append(app.users[:i], app.users[i+1:]...)
                        c.JSON(http.StatusOK, gin.H{
                                "message": "User deleted successfully",
                                "user":    user,
                        })
                        return
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})</span>
}

func (app *App) searchUsers(c *gin.Context) <span class="cov0" title="0">{
        query := c.Query("q")
        if query == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Query parameter 'q' is required"})
                return
        }</span>

        <span class="cov0" title="0">var results []User
        for _, user := range app.users </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(user.Name), strings.ToLower(query)) ||
                        strings.Contains(strings.ToLower(user.Username), strings.ToLower(query)) ||
                        strings.Contains(strings.ToLower(user.Email), strings.ToLower(query)) </span><span class="cov0" title="0">{
                        results = append(results, user)
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "query":   query,
                "results": results,
                "count":   len(results),
        })</span>
}

func (app *App) statusHandler(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "service":     "gin-service",
                "version":     "1.0.0",
                "maintenance": app.manager.IsInMaintenance(),
                "uptime":      time.Now().Format(time.RFC3339),
                "users_count": len(app.users),
                "gin_mode":    gin.Mode(),
        })
}</span>

// Static content handlers
func (app *App) indexHandler(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message": "Welcome to Gin Service with GoMaint!",
                "service": "gin-service",
                "endpoints": gin.H{
                        "health":  "/health",
                        "ping":    "/ping",
                        "metrics": "/metrics",
                        "users":   "/api/v1/users",
                        "search":  "/api/v1/search/users?q=query",
                        "status":  "/api/v1/status",
                },
                "maintenance": app.manager.IsInMaintenance(),
                "timestamp":   time.Now().UTC(),
        })
}</span>

func (app *App) aboutHandler(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "service":     "gin-service",
                "description": "A demonstration of GoMaint maintenance mode with Gin framework",
                "framework":   "Gin",
                "features": []string{
                        "RESTful API with CRUD operations",
                        "Maintenance mode support",
                        "Graceful shutdown",
                        "Health checks",
                        "Search functionality",
                        "In-memory data store",
                },
                "maintenance": app.manager.IsInMaintenance(),
                "timestamp":   time.Now().UTC(),
        })
}</span>

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/abhishekvarshney/gomaint"

        "github.com/abhishekvarshney/gomaint/pkg/handlers/database"
        _ "github.com/lib/pq"
)

// MockDB implements the database.DB interface for demonstration
type MockDB struct {
        db *sql.DB
}

func (m *MockDB) DB() (*sql.DB, error) <span class="cov0" title="0">{
        return m.db, nil
}</span>

// User model for demonstration
type User struct {
        ID        int       `json:"id"`
        Name      string    `json:"name"`
        Email     string    `json:"email"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// App holds the application dependencies
type App struct {
        db      *sql.DB
        manager *gomaint.Manager
        server  *http.Server
}

func main() <span class="cov0" title="0">{
        fmt.Println("Database Service with Maintenance Mode")
        fmt.Println("=======================================")

        app, err := setupApp()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to setup application: %v", err)
        }</span>

        // Setup graceful shutdown
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle shutdown signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                log.Println("Shutting down...")
                cancel()
        }</span>()

        // Start the application
        <span class="cov0" title="0">if err := app.run(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Application failed: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Application stopped")</span>
}

func setupApp() (*App, error) <span class="cov0" title="0">{
        host := "postgres"
        port := 5432
        user := "postgres"
        password := "postgres"
        dbname := "testdb"
        sslmode := "disable"

        // 2. Construct the connection string (DSN)
        psqlInfo := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                host, port, user, password, dbname, sslmode)

        db, err := sql.Open("postgres", psqlInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create in-memory database: %w", err)
        }</span>

        // Create users table
        <span class="cov0" title="0">if err := createUsersTable(db); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create users table: %w", err)
        }</span>

        // Create database handler (works with GORM, XORM, or any ORM with sql.DB access)
        <span class="cov0" title="0">mockDB := &amp;MockDB{db: db}
        dbHandler := database.NewDatabaseHandler("database", mockDB, 30*time.Second, log.Default())

        // Create maintenance manager using new simplified API
        endpoints := []string{getEnv("ETCD_ENDPOINTS", "localhost:2379")}
        mgr, err := gomaint.StartWithEtcd(
                context.Background(),
                endpoints,
                "/maintenance/database-service",
                30*time.Second,
                dbHandler, // Register handler during creation
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create maintenance manager: %w", err)
        }</span>

        // Setup HTTP server
        <span class="cov0" title="0">mux := http.NewServeMux()
        app := &amp;App{
                db:      db,
                manager: mgr,
                server: &amp;http.Server{
                        Addr:    ":8080",
                        Handler: mux,
                },
        }

        // Setup routes
        app.setupRoutes(mux)

        return app, nil</span>
}

func createUsersTable(db *sql.DB) error <span class="cov0" title="0">{
        query := `
        CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,  -- or BIGSERIAL for a larger range
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)`

        _, err := db.Exec(query)
        return err
}</span>

func (app *App) setupRoutes(mux *http.ServeMux) <span class="cov0" title="0">{
        // Health check endpoint
        mux.HandleFunc("/health", app.healthHandler)

        // User CRUD endpoints
        mux.HandleFunc("/users", app.usersHandler)
        mux.HandleFunc("/users/", app.userHandler)

        // Stats endpoint
        mux.HandleFunc("/stats", app.statsHandler)
}</span>

func (app *App) run(ctx context.Context) error <span class="cov0" title="0">{
        // Maintenance manager is already started by StartWithEtcd

        // Start HTTP server
        go func() </span><span class="cov0" title="0">{
                log.Printf("Starting HTTP server on %s", app.server.Addr)
                if err := app.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("HTTP server failed: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">fmt.Printf("Server running on http://localhost%s\n", app.server.Addr)
        fmt.Println("Endpoints:")
        fmt.Println("  Health check: http://localhost:8080/health")
        fmt.Println("  Users API: http://localhost:8080/users")
        fmt.Println("  Stats: http://localhost:8080/stats")
        fmt.Println()
        fmt.Println("To enable maintenance mode:")
        fmt.Println("  etcdctl put /maintenance/database-service true")
        fmt.Println()
        fmt.Println("To disable maintenance mode:")
        fmt.Println("  etcdctl put /maintenance/database-service false")
        fmt.Println()
        fmt.Println("Press Ctrl+C to stop...")

        // Wait for context cancellation
        &lt;-ctx.Done()

        // Graceful shutdown
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Stop maintenance manager
        app.manager.Stop()

        // Close database connection
        app.db.Close()

        // Shutdown HTTP server
        return app.server.Shutdown(shutdownCtx)</span>
}

func (app *App) healthHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if app.manager.IsInMaintenance() </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.Header().Set("Retry-After", "60")
                w.WriteHeader(http.StatusServiceUnavailable)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "error":   "Service Unavailable",
                        "message": "Service is currently under maintenance. Please try again later.",
                        "code":    503,
                })
                return
        }</span>

        // Check database health
        <span class="cov0" title="0">health := app.manager.GetHandlerHealth()
        allHealthy := true
        for _, healthy := range health </span><span class="cov0" title="0">{
                if !healthy </span><span class="cov0" title="0">{
                        allHealthy = false
                        break</span>
                }
        }

        <span class="cov0" title="0">status := "healthy"
        statusCode := http.StatusOK
        if !allHealthy </span><span class="cov0" title="0">{
                status = "unhealthy"
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "status":      status,
                "maintenance": app.manager.IsInMaintenance(),
                "handlers":    health,
                "timestamp":   time.Now().UTC(),
        })</span>
}

func (app *App) usersHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        /*
                if app.manager.IsInMaintenance() {
                        http.Error(w, "Service under maintenance", http.StatusServiceUnavailable)
                        return
                }
        */

        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                app.listUsers(w, r)</span>
        case http.MethodPost:<span class="cov0" title="0">
                app.createUser(w, r)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

func (app *App) userHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if app.manager.IsInMaintenance() </span><span class="cov0" title="0">{
                http.Error(w, "Service under maintenance", http.StatusServiceUnavailable)
                return
        }</span>

        // Extract user ID from path
        // This is a simple implementation - in production, use a proper router
        <span class="cov0" title="0">switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                app.getUser(w, r)</span>
        case http.MethodPut:<span class="cov0" title="0">
                app.updateUser(w, r)</span>
        case http.MethodDelete:<span class="cov0" title="0">
                app.deleteUser(w, r)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

func (app *App) listUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        rows, err := app.db.Query("SELECT id, name, email, created_at, updated_at FROM users ORDER BY id")
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to fetch users", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []User
        for rows.Next() </span><span class="cov0" title="0">{
                var user User
                if err := rows.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email, &amp;user.CreatedAt, &amp;user.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to scan user", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">users = append(users, user)</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(users)</span>
}

func (app *App) createUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var user User
        if err := json.NewDecoder(r.Body).Decode(&amp;user); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">query := "INSERT INTO users (name, email) VALUES (?, ?) RETURNING id, created_at, updated_at"
        err := app.db.QueryRow(query, user.Name, user.Email).Scan(&amp;user.ID, &amp;user.CreatedAt, &amp;user.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                // SQLite doesn't support RETURNING, so we need to do it differently
                result, err := app.db.Exec("INSERT INTO users (name, email) VALUES (?, ?)", user.Name, user.Email)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to create user", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">id, err := result.LastInsertId()
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to get user ID", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">user.ID = int(id)
                user.CreatedAt = time.Now()
                user.UpdatedAt = time.Now()</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(user)</span>
}

func (app *App) getUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Simple ID extraction - in production use proper routing
        id := r.URL.Path[len("/users/"):]

        var user User
        query := "SELECT id, name, email, created_at, updated_at FROM users WHERE id = ?"
        err := app.db.QueryRow(query, id).Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email, &amp;user.CreatedAt, &amp;user.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        http.Error(w, "User not found", http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Failed to fetch user", http.StatusInternalServerError)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)</span>
}

func (app *App) updateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.URL.Path[len("/users/"):]

        var updates User
        if err := json.NewDecoder(r.Body).Decode(&amp;updates); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">query := "UPDATE users SET name = ?, email = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?"
        result, err := app.db.Exec(query, updates.Name, updates.Email, id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to update user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get affected rows", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                http.Error(w, "User not found", http.StatusNotFound)
                return
        }</span>

        // Fetch the updated user
        <span class="cov0" title="0">var user User
        query = "SELECT id, name, email, created_at, updated_at FROM users WHERE id = ?"
        err = app.db.QueryRow(query, id).Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email, &amp;user.CreatedAt, &amp;user.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to fetch updated user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)</span>
}

func (app *App) deleteUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.URL.Path[len("/users/"):]

        result, err := app.db.Exec("DELETE FROM users WHERE id = ?", id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to delete user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to get affected rows", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                http.Error(w, "User not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (app *App) statsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get database handler stats
        var dbStats map[string]interface{}
        if handler, exists := app.manager.GetHandler("database"); exists </span><span class="cov0" title="0">{
                if dbHandler, ok := handler.(*database.Handler); ok </span><span class="cov0" title="0">{
                        dbStats = dbHandler.GetStats()
                }</span>
        }

        <span class="cov0" title="0">stats := map[string]interface{}{
                "maintenance": app.manager.IsInMaintenance(),
                "timestamp":   time.Now().UTC(),
                "handlers":    app.manager.GetHandlerHealth(),
                "database":    dbStats,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "log"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/health/grpc_health_v1"

        pb "github.com/abhishekvarshney/gomaint/examples/grpc-service/proto"
)

func main() <span class="cov0" title="0">{
        // Connect to gRPC server
        conn, err := grpc.Dial("localhost:50051", grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create clients
        userClient := pb.NewUserServiceClient(conn)
        healthClient := grpc_health_v1.NewHealthClient(conn)

        ctx := context.Background()

        fmt.Println("=== gRPC User Service Client Demo ===")

        // Test health check
        fmt.Println("\n1. Testing Health Check...")
        testHealthCheck(ctx, healthClient)

        // Test unary RPC
        fmt.Println("\n2. Testing Unary RPC (CreateUser)...")
        testCreateUser(ctx, userClient)

        // Test another unary RPC
        fmt.Println("\n3. Testing Unary RPC (ListUsers)...")
        testListUsers(ctx, userClient)

        // Test server streaming
        fmt.Println("\n4. Testing Server Streaming (StreamUsers)...")
        testStreamUsers(ctx, userClient)

        // Test client streaming
        fmt.Println("\n5. Testing Client Streaming (SubscribeToUserEvents)...")
        testSubscribeToUserEvents(ctx, userClient)

        // Test bidirectional streaming
        fmt.Println("\n6. Testing Bidirectional Streaming (ChatWithUsers)...")
        testChatWithUsers(ctx, userClient)

        fmt.Println("\n=== Demo Complete ===")</span>
}

func testHealthCheck(ctx context.Context, client grpc_health_v1.HealthClient) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        resp, err := client.Check(ctx, &amp;grpc_health_v1.HealthCheckRequest{})
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Health check failed: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Health status: %s\n", resp.Status.String())</span>
}

func testCreateUser(ctx context.Context, client pb.UserServiceClient) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        req := &amp;pb.CreateUserRequest{
                Name:  "Alice Cooper",
                Email: "alice.cooper@example.com",
        }

        resp, err := client.CreateUser(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("CreateUser failed: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Created user: %s (ID: %s)\n", resp.User.Name, resp.User.Id)
        fmt.Printf("Message: %s\n", resp.Message)</span>
}

func testListUsers(ctx context.Context, client pb.UserServiceClient) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        req := &amp;pb.ListUsersRequest{
                Page:       1,
                PageSize:   10,
                ActiveOnly: false,
        }

        resp, err := client.ListUsers(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ListUsers failed: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Found %d users (page %d, page size %d):\n", resp.TotalCount, resp.Page, resp.PageSize)
        for i, user := range resp.Users </span><span class="cov0" title="0">{
                status := "active"
                if !user.Active </span><span class="cov0" title="0">{
                        status = "inactive"
                }</span>
                <span class="cov0" title="0">fmt.Printf("  %d. %s (%s) - %s\n", i+1, user.Name, user.Email, status)</span>
        }
}

func testStreamUsers(ctx context.Context, client pb.UserServiceClient) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()

        req := &amp;pb.StreamUsersRequest{
                ActiveOnly: false,
                BatchSize:  2,
        }

        stream, err := client.StreamUsers(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("StreamUsers failed: %v", err)
                return
        }</span>

        <span class="cov0" title="0">batchCount := 0
        userCount := 0

        for </span><span class="cov0" title="0">{
                resp, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Stream receive error: %v", err)
                        break</span>
                }

                <span class="cov0" title="0">batchCount++
                fmt.Printf("Batch %d (%d users):\n", batchCount, len(resp.Users))
                for _, user := range resp.Users </span><span class="cov0" title="0">{
                        userCount++
                        status := "active"
                        if !user.Active </span><span class="cov0" title="0">{
                                status = "inactive"
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("  - %s (%s) - %s\n", user.Name, user.Email, status)</span>
                }

                <span class="cov0" title="0">if resp.IsLastBatch </span><span class="cov0" title="0">{
                        fmt.Printf("Stream complete. Received %d users in %d batches.\n", userCount, batchCount)
                        break</span>
                }
        }
}

func testSubscribeToUserEvents(ctx context.Context, client pb.UserServiceClient) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()

        stream, err := client.SubscribeToUserEvents(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("SubscribeToUserEvents failed: %v", err)
                return
        }</span>

        // Send multiple user creation requests
        <span class="cov0" title="0">users := []*pb.CreateUserRequest{
                {Name: "Stream User 1", Email: "stream1@example.com"},
                {Name: "Stream User 2", Email: "stream2@example.com"},
                {Name: "Stream User 3", Email: "stream3@example.com"},
        }

        fmt.Printf("Sending %d user creation requests...\n", len(users))
        for i, user := range users </span><span class="cov0" title="0">{
                if err := stream.Send(user); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to send user %d: %v", i+1, err)
                        break</span>
                }
                <span class="cov0" title="0">fmt.Printf("  Sent: %s (%s)\n", user.Name, user.Email)
                time.Sleep(500 * time.Millisecond)</span> // Small delay between sends
        }

        // Close the stream and get response
        <span class="cov0" title="0">_, err = stream.CloseAndRecv()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to close stream: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("Client streaming completed successfully!")</span>
}

func testChatWithUsers(ctx context.Context, client pb.UserServiceClient) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 15*time.Second)
        defer cancel()

        stream, err := client.ChatWithUsers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ChatWithUsers failed: %v", err)
                return
        }</span>

        // Channel to receive responses
        <span class="cov0" title="0">respChan := make(chan *pb.CreateUserResponse, 10)
        errChan := make(chan error, 1)

        // Goroutine to receive responses
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        resp, err := stream.Recv()
                        if err == io.EOF </span><span class="cov0" title="0">{
                                close(respChan)
                                return
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">respChan &lt;- resp</span>
                }
        }()

        // Send requests
        <span class="cov0" title="0">chatUsers := []*pb.CreateUserRequest{
                {Name: "Chat User 1", Email: "chat1@example.com"},
                {Name: "Chat User 2", Email: "chat2@example.com"},
                {Name: "Chat User 3", Email: "chat3@example.com"},
        }

        fmt.Printf("Starting chat with %d user creation requests...\n", len(chatUsers))

        for i, user := range chatUsers </span><span class="cov0" title="0">{
                // Send request
                if err := stream.Send(user); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to send chat user %d: %v", i+1, err)
                        break</span>
                }
                <span class="cov0" title="0">fmt.Printf("  Sent: %s (%s)\n", user.Name, user.Email)

                // Wait for response
                select </span>{
                case resp := &lt;-respChan:<span class="cov0" title="0">
                        if resp != nil </span><span class="cov0" title="0">{
                                fmt.Printf("  Received: %s (ID: %s) - %s\n",
                                        resp.User.Name, resp.User.Id, resp.Message)
                        }</span>
                case err := &lt;-errChan:<span class="cov0" title="0">
                        log.Printf("Error receiving response: %v", err)
                        return</span>
                case &lt;-time.After(2 * time.Second):<span class="cov0" title="0">
                        log.Printf("Timeout waiting for response to user %d", i+1)</span>
                }

                <span class="cov0" title="0">time.Sleep(500 * time.Millisecond)</span>
        }

        // Close the send side
        <span class="cov0" title="0">if err := stream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to close send: %v", err)
        }</span>

        // Wait for any remaining responses
        <span class="cov0" title="0">for resp := range respChan </span><span class="cov0" title="0">{
                if resp != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  Final response: %s - %s\n", resp.User.Name, resp.Message)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("Bidirectional streaming completed!")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/health/grpc_health_v1"
)

func main() <span class="cov0" title="0">{
        // Get server address from environment or use default
        serverAddr := os.Getenv("GRPC_SERVER")
        if serverAddr == "" </span><span class="cov0" title="0">{
                serverAddr = "localhost:50051"
        }</span>

        // Create connection with timeout
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()

        conn, err := grpc.DialContext(
                ctx,
                serverAddr,
                grpc.WithTransportCredentials(insecure.NewCredentials()),
                grpc.WithBlock(),
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to connect to gRPC server: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create health client
        healthClient := grpc_health_v1.NewHealthClient(conn)

        // Check health
        ctx, cancel = context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()

        resp, err := healthClient.Check(ctx, &amp;grpc_health_v1.HealthCheckRequest{
                Service: "", // Empty string checks overall server health
        })
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Health check failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if resp.Status != grpc_health_v1.HealthCheckResponse_SERVING </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Server is not serving (status: %s)\n", resp.Status.String())
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("Health check passed: server is healthy")
        os.Exit(0)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "net"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        clientv3 "go.etcd.io/etcd/client/v3"

        pb "github.com/abhishekvarshney/gomaint/examples/grpc-service/proto"
        "github.com/abhishekvarshney/gomaint/examples/grpc-service/server"
        grpchandler "github.com/abhishekvarshney/gomaint/pkg/handlers/grpc"
)

const (
        defaultPort         = "50051"
        defaultEtcdKey      = "/maintenance/grpc-service"
        defaultEtcdEndpoint = "localhost:2379"
        defaultDrainTimeout = 30 * time.Second
)

func main() <span class="cov0" title="0">{
        // Get configuration from environment variables
        port := getEnv("GRPC_PORT", defaultPort)
        etcdEndpoints := getEnv("ETCD_ENDPOINTS", defaultEtcdEndpoint)
        etcdKey := getEnv("ETCD_KEY", defaultEtcdKey)

        // Parse drain timeout
        drainTimeoutStr := getEnv("DRAIN_TIMEOUT", "30s")
        drainTimeout, err := time.ParseDuration(drainTimeoutStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Invalid DRAIN_TIMEOUT: %v", err)
        }</span>

        // Create TCP listener
        <span class="cov0" title="0">lis, err := net.Listen("tcp", fmt.Sprintf(":%s", port))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to listen: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("gRPC server starting on port %s", port)
        log.Printf("Drain timeout: %v", drainTimeout)
        log.Printf("etcd endpoints: %s", etcdEndpoints)
        log.Printf("etcd key: %s", etcdKey)

        // Create gRPC maintenance handler
        handler := grpchandler.NewGRPCHandler(lis, drainTimeout)

        // Create and register the user service
        userService := server.NewUserService()
        pb.RegisterUserServiceServer(handler.GetServer(), userService)

        // Set up etcd client and watcher
        endpoints := strings.Split(etcdEndpoints, ",")
        etcdClient, err := clientv3.New(clientv3.Config{
                Endpoints:   endpoints,
                DialTimeout: 5 * time.Second,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create etcd client: %v", err)
        }</span>
        <span class="cov0" title="0">defer etcdClient.Close()

        // Start the server
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        if err := handler.Start(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start gRPC handler: %v", err)
        }</span>

        // Start monitoring etcd for maintenance mode changes
        <span class="cov0" title="0">go monitorMaintenanceMode(ctx, etcdClient, etcdKey, handler)

        // Wait for interrupt signal
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        log.Println("gRPC server started successfully")
        log.Println("Monitoring etcd for maintenance mode changes...")
        log.Println("Press Ctrl+C to stop")

        &lt;-sigChan
        log.Println("Shutting down gRPC server...")

        // Graceful shutdown with timeout
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer shutdownCancel()

        if err := handler.Stop(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error during shutdown: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Println("Server stopped gracefully")
        }</span>
}

func monitorMaintenanceMode(ctx context.Context, client *clientv3.Client, key string, handler *grpchandler.Handler) <span class="cov0" title="0">{
        watchChan := client.Watch(ctx, key)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case watchResp := &lt;-watchChan:<span class="cov0" title="0">
                        for _, event := range watchResp.Events </span><span class="cov0" title="0">{
                                value := string(event.Kv.Value)
                                log.Printf("etcd event: %s = %s", string(event.Kv.Key), value)

                                switch strings.ToLower(value) </span>{
                                case "true", "1", "yes", "on":<span class="cov0" title="0">
                                        log.Println("Entering maintenance mode...")
                                        if err := handler.OnMaintenanceStart(ctx); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Error entering maintenance mode: %v", err)
                                        }</span> else<span class="cov0" title="0"> {
                                                log.Println("Successfully entered maintenance mode")
                                        }</span>
                                case "false", "0", "no", "off", "":<span class="cov0" title="0">
                                        log.Println("Exiting maintenance mode...")
                                        if err := handler.OnMaintenanceEnd(ctx); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Error exiting maintenance mode: %v", err)
                                        }</span> else<span class="cov0" title="0"> {
                                                log.Println("Successfully exited maintenance mode")
                                        }</span>
                                default:<span class="cov0" title="0">
                                        log.Printf("Unknown maintenance mode value: %s", value)</span>
                                }
                        }
                }
        }
}

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.8
//         protoc        v6.32.0
// source: user.proto

package proto

import (
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// User represents a user in the system
type User struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Email         string                 `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        UpdatedAt     *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
        Active        bool                   `protobuf:"varint,6,opt,name=active,proto3" json:"active,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *User) Reset() <span class="cov0" title="0">{
        *x = User{}
        mi := &amp;file_user_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *User) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*User) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *User) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{0}
}</span>

func (x *User) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetUpdatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetActive() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Active
        }</span>
        <span class="cov0" title="0">return false</span>
}

// CreateUserRequest represents a request to create a user
type CreateUserRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Email         string                 `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateUserRequest) Reset() <span class="cov0" title="0">{
        *x = CreateUserRequest{}
        mi := &amp;file_user_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateUserRequest.ProtoReflect.Descriptor instead.
func (*CreateUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CreateUserRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateUserRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// CreateUserResponse represents a response after creating a user
type CreateUserResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        User          *User                  `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateUserResponse) Reset() <span class="cov0" title="0">{
        *x = CreateUserResponse{}
        mi := &amp;file_user_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateUserResponse.ProtoReflect.Descriptor instead.
func (*CreateUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{2}
}</span>

func (x *CreateUserResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CreateUserResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetUserRequest represents a request to get a user by ID
type GetUserRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserRequest{}
        mi := &amp;file_user_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserRequest.ProtoReflect.Descriptor instead.
func (*GetUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetUserRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetUserResponse represents a response containing a user
type GetUserResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        User          *User                  `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserResponse{}
        mi := &amp;file_user_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserResponse.ProtoReflect.Descriptor instead.
func (*GetUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{4}
}</span>

func (x *GetUserResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateUserRequest represents a request to update a user
type UpdateUserRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Email         string                 `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        Active        bool                   `protobuf:"varint,4,opt,name=active,proto3" json:"active,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateUserRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateUserRequest{}
        mi := &amp;file_user_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateUserRequest.ProtoReflect.Descriptor instead.
func (*UpdateUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{5}
}</span>

func (x *UpdateUserRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateUserRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateUserRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateUserRequest) GetActive() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Active
        }</span>
        <span class="cov0" title="0">return false</span>
}

// UpdateUserResponse represents a response after updating a user
type UpdateUserResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        User          *User                  `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateUserResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateUserResponse{}
        mi := &amp;file_user_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateUserResponse.ProtoReflect.Descriptor instead.
func (*UpdateUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{6}
}</span>

func (x *UpdateUserResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UpdateUserResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// DeleteUserRequest represents a request to delete a user
type DeleteUserRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteUserRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteUserRequest{}
        mi := &amp;file_user_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteUserRequest.ProtoReflect.Descriptor instead.
func (*DeleteUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{7}
}</span>

func (x *DeleteUserRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// DeleteUserResponse represents a response after deleting a user
type DeleteUserResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Message       string                 `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteUserResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteUserResponse{}
        mi := &amp;file_user_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteUserResponse.ProtoReflect.Descriptor instead.
func (*DeleteUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{8}
}</span>

func (x *DeleteUserResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ListUsersRequest represents a request to list users
type ListUsersRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Page          int32                  `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
        PageSize      int32                  `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
        ActiveOnly    bool                   `protobuf:"varint,3,opt,name=active_only,json=activeOnly,proto3" json:"active_only,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListUsersRequest) Reset() <span class="cov0" title="0">{
        *x = ListUsersRequest{}
        mi := &amp;file_user_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListUsersRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListUsersRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListUsersRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListUsersRequest.ProtoReflect.Descriptor instead.
func (*ListUsersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{9}
}</span>

func (x *ListUsersRequest) GetPage() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Page
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListUsersRequest) GetPageSize() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PageSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListUsersRequest) GetActiveOnly() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActiveOnly
        }</span>
        <span class="cov0" title="0">return false</span>
}

// ListUsersResponse represents a response containing a list of users
type ListUsersResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Users         []*User                `protobuf:"bytes,1,rep,name=users,proto3" json:"users,omitempty"`
        TotalCount    int32                  `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
        Page          int32                  `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
        PageSize      int32                  `protobuf:"varint,4,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListUsersResponse) Reset() <span class="cov0" title="0">{
        *x = ListUsersResponse{}
        mi := &amp;file_user_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListUsersResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListUsersResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListUsersResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListUsersResponse.ProtoReflect.Descriptor instead.
func (*ListUsersResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{10}
}</span>

func (x *ListUsersResponse) GetUsers() []*User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Users
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListUsersResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListUsersResponse) GetPage() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Page
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListUsersResponse) GetPageSize() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PageSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// StreamUsersRequest represents a request to stream users
type StreamUsersRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ActiveOnly    bool                   `protobuf:"varint,1,opt,name=active_only,json=activeOnly,proto3" json:"active_only,omitempty"`
        BatchSize     int32                  `protobuf:"varint,2,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StreamUsersRequest) Reset() <span class="cov0" title="0">{
        *x = StreamUsersRequest{}
        mi := &amp;file_user_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StreamUsersRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StreamUsersRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StreamUsersRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StreamUsersRequest.ProtoReflect.Descriptor instead.
func (*StreamUsersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{11}
}</span>

func (x *StreamUsersRequest) GetActiveOnly() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActiveOnly
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StreamUsersRequest) GetBatchSize() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BatchSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// StreamUsersResponse represents a response in the user stream
type StreamUsersResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Users         []*User                `protobuf:"bytes,1,rep,name=users,proto3" json:"users,omitempty"`
        IsLastBatch   bool                   `protobuf:"varint,2,opt,name=is_last_batch,json=isLastBatch,proto3" json:"is_last_batch,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StreamUsersResponse) Reset() <span class="cov0" title="0">{
        *x = StreamUsersResponse{}
        mi := &amp;file_user_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StreamUsersResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StreamUsersResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StreamUsersResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StreamUsersResponse.ProtoReflect.Descriptor instead.
func (*StreamUsersResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{12}
}</span>

func (x *StreamUsersResponse) GetUsers() []*User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Users
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamUsersResponse) GetIsLastBatch() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsLastBatch
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_user_proto protoreflect.FileDescriptor

const file_user_proto_rawDesc = "" +
        "\n" +
        "\n" +
        "user.proto\x12\x04user\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/empty.proto\"\xce\x01\n" +
        "\x04User\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
        "\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
        "\x05email\x18\x03 \x01(\tR\x05email\x129\n" +
        "\n" +
        "created_at\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
        "\n" +
        "updated_at\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x12\x16\n" +
        "\x06active\x18\x06 \x01(\bR\x06active\"=\n" +
        "\x11CreateUserRequest\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
        "\x05email\x18\x02 \x01(\tR\x05email\"N\n" +
        "\x12CreateUserResponse\x12\x1e\n" +
        "\x04user\x18\x01 \x01(\v2\n" +
        ".user.UserR\x04user\x12\x18\n" +
        "\amessage\x18\x02 \x01(\tR\amessage\" \n" +
        "\x0eGetUserRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"1\n" +
        "\x0fGetUserResponse\x12\x1e\n" +
        "\x04user\x18\x01 \x01(\v2\n" +
        ".user.UserR\x04user\"e\n" +
        "\x11UpdateUserRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
        "\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
        "\x05email\x18\x03 \x01(\tR\x05email\x12\x16\n" +
        "\x06active\x18\x04 \x01(\bR\x06active\"N\n" +
        "\x12UpdateUserResponse\x12\x1e\n" +
        "\x04user\x18\x01 \x01(\v2\n" +
        ".user.UserR\x04user\x12\x18\n" +
        "\amessage\x18\x02 \x01(\tR\amessage\"#\n" +
        "\x11DeleteUserRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\".\n" +
        "\x12DeleteUserResponse\x12\x18\n" +
        "\amessage\x18\x01 \x01(\tR\amessage\"d\n" +
        "\x10ListUsersRequest\x12\x12\n" +
        "\x04page\x18\x01 \x01(\x05R\x04page\x12\x1b\n" +
        "\tpage_size\x18\x02 \x01(\x05R\bpageSize\x12\x1f\n" +
        "\vactive_only\x18\x03 \x01(\bR\n" +
        "activeOnly\"\x87\x01\n" +
        "\x11ListUsersResponse\x12 \n" +
        "\x05users\x18\x01 \x03(\v2\n" +
        ".user.UserR\x05users\x12\x1f\n" +
        "\vtotal_count\x18\x02 \x01(\x05R\n" +
        "totalCount\x12\x12\n" +
        "\x04page\x18\x03 \x01(\x05R\x04page\x12\x1b\n" +
        "\tpage_size\x18\x04 \x01(\x05R\bpageSize\"T\n" +
        "\x12StreamUsersRequest\x12\x1f\n" +
        "\vactive_only\x18\x01 \x01(\bR\n" +
        "activeOnly\x12\x1d\n" +
        "\n" +
        "batch_size\x18\x02 \x01(\x05R\tbatchSize\"[\n" +
        "\x13StreamUsersResponse\x12 \n" +
        "\x05users\x18\x01 \x03(\v2\n" +
        ".user.UserR\x05users\x12\"\n" +
        "\ris_last_batch\x18\x02 \x01(\bR\visLastBatch2\xa0\x04\n" +
        "\vUserService\x12?\n" +
        "\n" +
        "CreateUser\x12\x17.user.CreateUserRequest\x1a\x18.user.CreateUserResponse\x126\n" +
        "\aGetUser\x12\x14.user.GetUserRequest\x1a\x15.user.GetUserResponse\x12?\n" +
        "\n" +
        "UpdateUser\x12\x17.user.UpdateUserRequest\x1a\x18.user.UpdateUserResponse\x12?\n" +
        "\n" +
        "DeleteUser\x12\x17.user.DeleteUserRequest\x1a\x18.user.DeleteUserResponse\x12&lt;\n" +
        "\tListUsers\x12\x16.user.ListUsersRequest\x1a\x17.user.ListUsersResponse\x12D\n" +
        "\vStreamUsers\x12\x18.user.StreamUsersRequest\x1a\x19.user.StreamUsersResponse0\x01\x12J\n" +
        "\x15SubscribeToUserEvents\x12\x17.user.CreateUserRequest\x1a\x16.google.protobuf.Empty(\x01\x12F\n" +
        "\rChatWithUsers\x12\x17.user.CreateUserRequest\x1a\x18.user.CreateUserResponse(\x010\x01BAZ?github.com/abhishekvarshney/gomaint/examples/grpc-service/protob\x06proto3"

var (
        file_user_proto_rawDescOnce sync.Once
        file_user_proto_rawDescData []byte
)

func file_user_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_user_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_user_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_user_proto_rawDesc), len(file_user_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_user_proto_rawDescData</span>
}

var file_user_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_user_proto_goTypes = []any{
        (*User)(nil),                  // 0: user.User
        (*CreateUserRequest)(nil),     // 1: user.CreateUserRequest
        (*CreateUserResponse)(nil),    // 2: user.CreateUserResponse
        (*GetUserRequest)(nil),        // 3: user.GetUserRequest
        (*GetUserResponse)(nil),       // 4: user.GetUserResponse
        (*UpdateUserRequest)(nil),     // 5: user.UpdateUserRequest
        (*UpdateUserResponse)(nil),    // 6: user.UpdateUserResponse
        (*DeleteUserRequest)(nil),     // 7: user.DeleteUserRequest
        (*DeleteUserResponse)(nil),    // 8: user.DeleteUserResponse
        (*ListUsersRequest)(nil),      // 9: user.ListUsersRequest
        (*ListUsersResponse)(nil),     // 10: user.ListUsersResponse
        (*StreamUsersRequest)(nil),    // 11: user.StreamUsersRequest
        (*StreamUsersResponse)(nil),   // 12: user.StreamUsersResponse
        (*timestamppb.Timestamp)(nil), // 13: google.protobuf.Timestamp
        (*emptypb.Empty)(nil),         // 14: google.protobuf.Empty
}
var file_user_proto_depIdxs = []int32{
        13, // 0: user.User.created_at:type_name -&gt; google.protobuf.Timestamp
        13, // 1: user.User.updated_at:type_name -&gt; google.protobuf.Timestamp
        0,  // 2: user.CreateUserResponse.user:type_name -&gt; user.User
        0,  // 3: user.GetUserResponse.user:type_name -&gt; user.User
        0,  // 4: user.UpdateUserResponse.user:type_name -&gt; user.User
        0,  // 5: user.ListUsersResponse.users:type_name -&gt; user.User
        0,  // 6: user.StreamUsersResponse.users:type_name -&gt; user.User
        1,  // 7: user.UserService.CreateUser:input_type -&gt; user.CreateUserRequest
        3,  // 8: user.UserService.GetUser:input_type -&gt; user.GetUserRequest
        5,  // 9: user.UserService.UpdateUser:input_type -&gt; user.UpdateUserRequest
        7,  // 10: user.UserService.DeleteUser:input_type -&gt; user.DeleteUserRequest
        9,  // 11: user.UserService.ListUsers:input_type -&gt; user.ListUsersRequest
        11, // 12: user.UserService.StreamUsers:input_type -&gt; user.StreamUsersRequest
        1,  // 13: user.UserService.SubscribeToUserEvents:input_type -&gt; user.CreateUserRequest
        1,  // 14: user.UserService.ChatWithUsers:input_type -&gt; user.CreateUserRequest
        2,  // 15: user.UserService.CreateUser:output_type -&gt; user.CreateUserResponse
        4,  // 16: user.UserService.GetUser:output_type -&gt; user.GetUserResponse
        6,  // 17: user.UserService.UpdateUser:output_type -&gt; user.UpdateUserResponse
        8,  // 18: user.UserService.DeleteUser:output_type -&gt; user.DeleteUserResponse
        10, // 19: user.UserService.ListUsers:output_type -&gt; user.ListUsersResponse
        12, // 20: user.UserService.StreamUsers:output_type -&gt; user.StreamUsersResponse
        14, // 21: user.UserService.SubscribeToUserEvents:output_type -&gt; google.protobuf.Empty
        2,  // 22: user.UserService.ChatWithUsers:output_type -&gt; user.CreateUserResponse
        15, // [15:23] is the sub-list for method output_type
        7,  // [7:15] is the sub-list for method input_type
        7,  // [7:7] is the sub-list for extension type_name
        7,  // [7:7] is the sub-list for extension extendee
        0,  // [0:7] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_user_proto_init() }</span>
func file_user_proto_init() <span class="cov0" title="0">{
        if File_user_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_user_proto_rawDesc), len(file_user_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   13,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_user_proto_goTypes,
                DependencyIndexes: file_user_proto_depIdxs,
                MessageInfos:      file_user_proto_msgTypes,
        }.Build()
        File_user_proto = out.File
        file_user_proto_goTypes = nil
        file_user_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.0
// source: user.proto

package proto

import (
        context "context"

        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        UserService_CreateUser_FullMethodName            = "/user.UserService/CreateUser"
        UserService_GetUser_FullMethodName               = "/user.UserService/GetUser"
        UserService_UpdateUser_FullMethodName            = "/user.UserService/UpdateUser"
        UserService_DeleteUser_FullMethodName            = "/user.UserService/DeleteUser"
        UserService_ListUsers_FullMethodName             = "/user.UserService/ListUsers"
        UserService_StreamUsers_FullMethodName           = "/user.UserService/StreamUsers"
        UserService_SubscribeToUserEvents_FullMethodName = "/user.UserService/SubscribeToUserEvents"
        UserService_ChatWithUsers_FullMethodName         = "/user.UserService/ChatWithUsers"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// UserService defines the gRPC service for user management
type UserServiceClient interface {
        // CreateUser creates a new user
        CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
        // GetUser retrieves a user by ID
        GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
        // UpdateUser updates an existing user
        UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error)
        // DeleteUser deletes a user by ID
        DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error)
        // ListUsers lists users with pagination
        ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error)
        // StreamUsers streams users in batches (server streaming)
        StreamUsers(ctx context.Context, in *StreamUsersRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUsersResponse], error)
        // SubscribeToUserEvents subscribes to user events (client streaming)
        SubscribeToUserEvents(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[CreateUserRequest, emptypb.Empty], error)
        // ChatWithUsers demonstrates bidirectional streaming
        ChatWithUsers(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[CreateUserRequest, CreateUserResponse], error)
}

type userServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient <span class="cov0" title="0">{
        return &amp;userServiceClient{cc}
}</span>

func (c *userServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateUserResponse)
        err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserResponse)
        err := c.cc.Invoke(ctx, UserService_GetUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateUserResponse)
        err := c.cc.Invoke(ctx, UserService_UpdateUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteUserResponse)
        err := c.cc.Invoke(ctx, UserService_DeleteUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListUsersResponse)
        err := c.cc.Invoke(ctx, UserService_ListUsers_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) StreamUsers(ctx context.Context, in *StreamUsersRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUsersResponse], error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        stream, err := c.cc.NewStream(ctx, &amp;UserService_ServiceDesc.Streams[0], UserService_StreamUsers_FullMethodName, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;grpc.GenericClientStream[StreamUsersRequest, StreamUsersResponse]{ClientStream: stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type UserService_StreamUsersClient = grpc.ServerStreamingClient[StreamUsersResponse]

func (c *userServiceClient) SubscribeToUserEvents(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[CreateUserRequest, emptypb.Empty], error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        stream, err := c.cc.NewStream(ctx, &amp;UserService_ServiceDesc.Streams[1], UserService_SubscribeToUserEvents_FullMethodName, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;grpc.GenericClientStream[CreateUserRequest, emptypb.Empty]{ClientStream: stream}
        return x, nil</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type UserService_SubscribeToUserEventsClient = grpc.ClientStreamingClient[CreateUserRequest, emptypb.Empty]

func (c *userServiceClient) ChatWithUsers(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[CreateUserRequest, CreateUserResponse], error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        stream, err := c.cc.NewStream(ctx, &amp;UserService_ServiceDesc.Streams[2], UserService_ChatWithUsers_FullMethodName, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;grpc.GenericClientStream[CreateUserRequest, CreateUserResponse]{ClientStream: stream}
        return x, nil</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type UserService_ChatWithUsersClient = grpc.BidiStreamingClient[CreateUserRequest, CreateUserResponse]

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
//
// UserService defines the gRPC service for user management
type UserServiceServer interface {
        // CreateUser creates a new user
        CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
        // GetUser retrieves a user by ID
        GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
        // UpdateUser updates an existing user
        UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error)
        // DeleteUser deletes a user by ID
        DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
        // ListUsers lists users with pagination
        ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error)
        // StreamUsers streams users in batches (server streaming)
        StreamUsers(*StreamUsersRequest, grpc.ServerStreamingServer[StreamUsersResponse]) error
        // SubscribeToUserEvents subscribes to user events (client streaming)
        SubscribeToUserEvents(grpc.ClientStreamingServer[CreateUserRequest, emptypb.Empty]) error
        // ChatWithUsers demonstrates bidirectional streaming
        ChatWithUsers(grpc.BidiStreamingServer[CreateUserRequest, CreateUserResponse]) error
        mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}</span>
func (UnimplementedUserServiceServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}</span>
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}</span>
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}</span>
func (UnimplementedUserServiceServer) ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}</span>
func (UnimplementedUserServiceServer) StreamUsers(*StreamUsersRequest, grpc.ServerStreamingServer[StreamUsersResponse]) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method StreamUsers not implemented")
}</span>
func (UnimplementedUserServiceServer) SubscribeToUserEvents(grpc.ClientStreamingServer[CreateUserRequest, emptypb.Empty]) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method SubscribeToUserEvents not implemented")
}</span>
func (UnimplementedUserServiceServer) ChatWithUsers(grpc.BidiStreamingServer[CreateUserRequest, CreateUserResponse]) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method ChatWithUsers not implemented")
}</span>
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
        mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedUserServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;UserService_ServiceDesc, srv)</span>
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).CreateUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_CreateUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_GetUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetUser(ctx, req.(*GetUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdateUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_UpdateUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).DeleteUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_DeleteUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).DeleteUser(ctx, req.(*DeleteUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListUsersRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).ListUsers(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_ListUsers_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).ListUsers(ctx, req.(*ListUsersRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_StreamUsers_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(StreamUsersRequest)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(UserServiceServer).StreamUsers(m, &amp;grpc.GenericServerStream[StreamUsersRequest, StreamUsersResponse]{ServerStream: stream})</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type UserService_StreamUsersServer = grpc.ServerStreamingServer[StreamUsersResponse]

func _UserService_SubscribeToUserEvents_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(UserServiceServer).SubscribeToUserEvents(&amp;grpc.GenericServerStream[CreateUserRequest, emptypb.Empty]{ServerStream: stream})
}</span>

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type UserService_SubscribeToUserEventsServer = grpc.ClientStreamingServer[CreateUserRequest, emptypb.Empty]

func _UserService_ChatWithUsers_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(UserServiceServer).ChatWithUsers(&amp;grpc.GenericServerStream[CreateUserRequest, CreateUserResponse]{ServerStream: stream})
}</span>

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type UserService_ChatWithUsersServer = grpc.BidiStreamingServer[CreateUserRequest, CreateUserResponse]

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "user.UserService",
        HandlerType: (*UserServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateUser",
                        Handler:    _UserService_CreateUser_Handler,
                },
                {
                        MethodName: "GetUser",
                        Handler:    _UserService_GetUser_Handler,
                },
                {
                        MethodName: "UpdateUser",
                        Handler:    _UserService_UpdateUser_Handler,
                },
                {
                        MethodName: "DeleteUser",
                        Handler:    _UserService_DeleteUser_Handler,
                },
                {
                        MethodName: "ListUsers",
                        Handler:    _UserService_ListUsers_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "StreamUsers",
                        Handler:       _UserService_StreamUsers_Handler,
                        ServerStreams: true,
                },
                {
                        StreamName:    "SubscribeToUserEvents",
                        Handler:       _UserService_SubscribeToUserEvents_Handler,
                        ClientStreams: true,
                },
                {
                        StreamName:    "ChatWithUsers",
                        Handler:       _UserService_ChatWithUsers_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
        },
        Metadata: "user.proto",
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package server

import (
        "context"
        "fmt"
        "io"
        "sync"
        "time"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        "google.golang.org/protobuf/types/known/timestamppb"

        pb "github.com/abhishekvarshney/gomaint/examples/grpc-service/proto"
        "github.com/google/uuid"
)

// UserService implements the UserService gRPC interface
type UserService struct {
        pb.UnimplementedUserServiceServer
        users map[string]*pb.User
        mutex sync.RWMutex
}

// NewUserService creates a new UserService instance
func NewUserService() *UserService <span class="cov0" title="0">{
        service := &amp;UserService{
                users: make(map[string]*pb.User),
        }

        // Add some sample users
        service.seedUsers()
        return service
}</span>

// seedUsers adds some initial users for testing
func (s *UserService) seedUsers() <span class="cov0" title="0">{
        now := timestamppb.Now()

        sampleUsers := []*pb.User{
                {
                        Id:        uuid.New().String(),
                        Name:      "John Doe",
                        Email:     "john.doe@example.com",
                        CreatedAt: now,
                        UpdatedAt: now,
                        Active:    true,
                },
                {
                        Id:        uuid.New().String(),
                        Name:      "Jane Smith",
                        Email:     "jane.smith@example.com",
                        CreatedAt: now,
                        UpdatedAt: now,
                        Active:    true,
                },
                {
                        Id:        uuid.New().String(),
                        Name:      "Bob Johnson",
                        Email:     "bob.johnson@example.com",
                        CreatedAt: now,
                        UpdatedAt: now,
                        Active:    false,
                },
        }

        for _, user := range sampleUsers </span><span class="cov0" title="0">{
                s.users[user.Id] = user
        }</span>
}

// CreateUser creates a new user
func (s *UserService) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.CreateUserResponse, error) <span class="cov0" title="0">{
        if req.Name == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "name is required")
        }</span>
        <span class="cov0" title="0">if req.Email == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "email is required")
        }</span>

        <span class="cov0" title="0">s.mutex.Lock()
        defer s.mutex.Unlock()

        // Check for duplicate email
        for _, user := range s.users </span><span class="cov0" title="0">{
                if user.Email == req.Email </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.AlreadyExists, "user with this email already exists")
                }</span>
        }

        <span class="cov0" title="0">now := timestamppb.Now()
        user := &amp;pb.User{
                Id:        uuid.New().String(),
                Name:      req.Name,
                Email:     req.Email,
                CreatedAt: now,
                UpdatedAt: now,
                Active:    true,
        }

        s.users[user.Id] = user

        return &amp;pb.CreateUserResponse{
                User:    user,
                Message: fmt.Sprintf("User %s created successfully", user.Name),
        }, nil</span>
}

// GetUser retrieves a user by ID
func (s *UserService) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) <span class="cov0" title="0">{
        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "user ID is required")
        }</span>

        <span class="cov0" title="0">s.mutex.RLock()
        defer s.mutex.RUnlock()

        user, exists := s.users[req.Id]
        if !exists </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, "user not found")
        }</span>

        <span class="cov0" title="0">return &amp;pb.GetUserResponse{
                User: user,
        }, nil</span>
}

// UpdateUser updates an existing user
func (s *UserService) UpdateUser(ctx context.Context, req *pb.UpdateUserRequest) (*pb.UpdateUserResponse, error) <span class="cov0" title="0">{
        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "user ID is required")
        }</span>

        <span class="cov0" title="0">s.mutex.Lock()
        defer s.mutex.Unlock()

        user, exists := s.users[req.Id]
        if !exists </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, "user not found")
        }</span>

        // Update fields if provided
        <span class="cov0" title="0">updated := false
        if req.Name != "" &amp;&amp; req.Name != user.Name </span><span class="cov0" title="0">{
                user.Name = req.Name
                updated = true
        }</span>
        <span class="cov0" title="0">if req.Email != "" &amp;&amp; req.Email != user.Email </span><span class="cov0" title="0">{
                // Check for duplicate email
                for id, existingUser := range s.users </span><span class="cov0" title="0">{
                        if id != req.Id &amp;&amp; existingUser.Email == req.Email </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.AlreadyExists, "user with this email already exists")
                        }</span>
                }
                <span class="cov0" title="0">user.Email = req.Email
                updated = true</span>
        }
        <span class="cov0" title="0">if user.Active != req.Active </span><span class="cov0" title="0">{
                user.Active = req.Active
                updated = true
        }</span>

        <span class="cov0" title="0">if updated </span><span class="cov0" title="0">{
                user.UpdatedAt = timestamppb.Now()
        }</span>

        <span class="cov0" title="0">return &amp;pb.UpdateUserResponse{
                User:    user,
                Message: fmt.Sprintf("User %s updated successfully", user.Name),
        }, nil</span>
}

// DeleteUser deletes a user by ID
func (s *UserService) DeleteUser(ctx context.Context, req *pb.DeleteUserRequest) (*pb.DeleteUserResponse, error) <span class="cov0" title="0">{
        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "user ID is required")
        }</span>

        <span class="cov0" title="0">s.mutex.Lock()
        defer s.mutex.Unlock()

        user, exists := s.users[req.Id]
        if !exists </span><span class="cov0" title="0">{
                return nil, status.Error(codes.NotFound, "user not found")
        }</span>

        <span class="cov0" title="0">delete(s.users, req.Id)

        return &amp;pb.DeleteUserResponse{
                Message: fmt.Sprintf("User %s deleted successfully", user.Name),
        }, nil</span>
}

// ListUsers lists users with pagination
func (s *UserService) ListUsers(ctx context.Context, req *pb.ListUsersRequest) (*pb.ListUsersResponse, error) <span class="cov0" title="0">{
        s.mutex.RLock()
        defer s.mutex.RUnlock()

        // Set defaults
        page := req.Page
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">pageSize := req.PageSize
        if pageSize &lt; 1 </span><span class="cov0" title="0">{
                pageSize = 10
        }</span>
        <span class="cov0" title="0">if pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 100 // Cap at 100
        }</span>

        // Filter users
        <span class="cov0" title="0">var filteredUsers []*pb.User
        for _, user := range s.users </span><span class="cov0" title="0">{
                if req.ActiveOnly &amp;&amp; !user.Active </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">filteredUsers = append(filteredUsers, user)</span>
        }

        <span class="cov0" title="0">totalCount := int32(len(filteredUsers))

        // Paginate
        startIdx := (page - 1) * pageSize
        endIdx := startIdx + pageSize

        if startIdx &gt;= totalCount </span><span class="cov0" title="0">{
                return &amp;pb.ListUsersResponse{
                        Users:      []*pb.User{},
                        TotalCount: totalCount,
                        Page:       page,
                        PageSize:   pageSize,
                }, nil
        }</span>

        <span class="cov0" title="0">if endIdx &gt; totalCount </span><span class="cov0" title="0">{
                endIdx = totalCount
        }</span>

        <span class="cov0" title="0">pageUsers := filteredUsers[startIdx:endIdx]

        return &amp;pb.ListUsersResponse{
                Users:      pageUsers,
                TotalCount: totalCount,
                Page:       page,
                PageSize:   pageSize,
        }, nil</span>
}

// StreamUsers streams users in batches (server streaming)
func (s *UserService) StreamUsers(req *pb.StreamUsersRequest, stream pb.UserService_StreamUsersServer) error <span class="cov0" title="0">{
        s.mutex.RLock()
        defer s.mutex.RUnlock()

        batchSize := req.BatchSize
        if batchSize &lt; 1 </span><span class="cov0" title="0">{
                batchSize = 5 // Default batch size
        }</span>
        <span class="cov0" title="0">if batchSize &gt; 50 </span><span class="cov0" title="0">{
                batchSize = 50 // Cap at 50
        }</span>

        // Filter users
        <span class="cov0" title="0">var users []*pb.User
        for _, user := range s.users </span><span class="cov0" title="0">{
                if req.ActiveOnly &amp;&amp; !user.Active </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">users = append(users, user)</span>
        }

        // Stream users in batches
        <span class="cov0" title="0">for i := 0; i &lt; len(users); i += int(batchSize) </span><span class="cov0" title="0">{
                end := i + int(batchSize)
                if end &gt; len(users) </span><span class="cov0" title="0">{
                        end = len(users)
                }</span>

                <span class="cov0" title="0">batch := users[i:end]
                isLastBatch := end &gt;= len(users)

                response := &amp;pb.StreamUsersResponse{
                        Users:       batch,
                        IsLastBatch: isLastBatch,
                }

                if err := stream.Send(response); err != nil </span><span class="cov0" title="0">{
                        return status.Error(codes.Internal, fmt.Sprintf("failed to send batch: %v", err))
                }</span>

                // Add a small delay to simulate processing
                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// SubscribeToUserEvents subscribes to user events (client streaming)
func (s *UserService) SubscribeToUserEvents(stream pb.UserService_SubscribeToUserEventsServer) error <span class="cov0" title="0">{
        var createdUsers []*pb.User

        for </span><span class="cov0" title="0">{
                req, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        // Client finished sending
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return status.Error(codes.Internal, fmt.Sprintf("failed to receive: %v", err))
                }</span>

                // Process the user creation request
                <span class="cov0" title="0">s.mutex.Lock()
                now := timestamppb.Now()
                user := &amp;pb.User{
                        Id:        uuid.New().String(),
                        Name:      req.Name,
                        Email:     req.Email,
                        CreatedAt: now,
                        UpdatedAt: now,
                        Active:    true,
                }
                s.users[user.Id] = user
                createdUsers = append(createdUsers, user)
                s.mutex.Unlock()

                // Log the created user (in a real app, this might publish to an event system)
                fmt.Printf("Created user via streaming: %s (%s)\n", user.Name, user.Email)</span>
        }

        <span class="cov0" title="0">fmt.Printf("Client streaming completed. Created %d users\n", len(createdUsers))
        return stream.SendAndClose(&amp;emptypb.Empty{})</span>
}

// ChatWithUsers demonstrates bidirectional streaming
func (s *UserService) ChatWithUsers(stream pb.UserService_ChatWithUsersServer) error <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                req, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return status.Error(codes.Internal, fmt.Sprintf("failed to receive: %v", err))
                }</span>

                // Process the request and create a user
                <span class="cov0" title="0">s.mutex.Lock()
                now := timestamppb.Now()
                user := &amp;pb.User{
                        Id:        uuid.New().String(),
                        Name:      req.Name,
                        Email:     req.Email,
                        CreatedAt: now,
                        UpdatedAt: now,
                        Active:    true,
                }
                s.users[user.Id] = user
                s.mutex.Unlock()

                // Send response back
                response := &amp;pb.CreateUserResponse{
                        User:    user,
                        Message: fmt.Sprintf("User %s created via chat stream", user.Name),
                }

                if err := stream.Send(response); err != nil </span><span class="cov0" title="0">{
                        return status.Error(codes.Internal, fmt.Sprintf("failed to send response: %v", err))
                }</span>

                <span class="cov0" title="0">fmt.Printf("Chat stream - Created user: %s (%s)\n", user.Name, user.Email)</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "context"
        "log"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/abhishekvarshney/gomaint"
        httpHandler "github.com/abhishekvarshney/gomaint/pkg/handlers/http"
)

const (
        defaultPort         = "8080"
        defaultEtcdKey      = "/maintenance/http-service"
        defaultEtcdEndpoint = "localhost:2379"
        defaultDrainTimeout = 30 * time.Second
)

func main() <span class="cov0" title="0">{
        // Get configuration from environment variables
        port := getEnv("HTTP_PORT", defaultPort)
        etcdEndpoints := getEnv("ETCD_ENDPOINTS", defaultEtcdEndpoint)
        etcdKey := getEnv("ETCD_KEY", defaultEtcdKey)

        // Parse drain timeout
        drainTimeoutStr := getEnv("DRAIN_TIMEOUT", "30s")
        drainTimeout, err := time.ParseDuration(drainTimeoutStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Invalid DRAIN_TIMEOUT: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("HTTP server starting on port %s", port)
        log.Printf("Drain timeout: %v", drainTimeout)
        log.Printf("etcd endpoints: %s", etcdEndpoints)
        log.Printf("etcd key: %s", etcdKey)

        // Create HTTP server and routes
        mux := http.NewServeMux()

        // Add routes
        mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                w.Write([]byte("Hello, World!"))
        }</span>)

        <span class="cov0" title="0">mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                w.Write([]byte(`{"status": "healthy", "timestamp": "` + time.Now().Format(time.RFC3339) + `"}`))
        }</span>)

        <span class="cov0" title="0">mux.HandleFunc("/api/data", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                w.Write([]byte(`{"message": "API is working", "timestamp": "` + time.Now().Format(time.RFC3339) + `"}`))
        }</span>)

        <span class="cov0" title="0">server := &amp;http.Server{
                Addr:    ":" + port,
                Handler: mux,
        }

        // Create HTTP handler for maintenance mode
        handler := httpHandler.NewHTTPHandler(server, drainTimeout)

        // Skip health check endpoints from maintenance mode
        handler.SkipPaths("/health")

        // Parse etcd endpoints
        endpoints := strings.Split(etcdEndpoints, ",")

        // Start server using the new simplified event source architecture
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        mgr, err := gomaint.StartWithEtcd(ctx, endpoints, etcdKey, drainTimeout, handler)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start maintenance manager: %v", err)
        }</span>
        <span class="cov0" title="0">defer mgr.Stop()

        // Start HTTP server in a goroutine
        go func() </span><span class="cov0" title="0">{
                log.Printf("Starting HTTP server on :%s", port)
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("HTTP server failed: %v", err)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        log.Println("HTTP server started successfully")
        log.Println("Monitoring etcd for maintenance mode changes...")
        log.Println("Press Ctrl+C to stop")

        &lt;-sigChan
        log.Println("Shutting down HTTP server...")

        // Graceful shutdown
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer shutdownCancel()

        if err := server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Printf("HTTP server shutdown error: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Println("HTTP server stopped gracefully")
        }</span>
}

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "math/rand"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/IBM/sarama"

        "github.com/abhishekvarshney/gomaint"
        kafkaHandler "github.com/abhishekvarshney/gomaint/pkg/handlers/kafka"
)

// MessageProcessor implements the Kafka message processing logic
type MessageProcessor struct {
        logger *log.Logger
}

// ProcessMessage processes a single Kafka message
func (mp *MessageProcessor) ProcessMessage(ctx context.Context, message *sarama.ConsumerMessage) error <span class="cov0" title="0">{
        messageBody := string(message.Value)

        mp.logger.Printf("Processing message from topic %s partition %d offset %d: %s",
                message.Topic, message.Partition, message.Offset, messageBody)

        // Simulate processing time (1-3 seconds)
        processingTime := time.Duration(1+rand.Intn(3)) * time.Second

        // Check for context cancellation during processing
        timer := time.NewTimer(processingTime)
        defer timer.Stop()

        select </span>{
        case &lt;-timer.C:<span class="cov0" title="0">
                // Processing completed successfully
                mp.logger.Printf("Successfully processed message from topic %s partition %d offset %d after %v",
                        message.Topic, message.Partition, message.Offset, processingTime)
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                mp.logger.Printf("Processing cancelled for message from topic %s partition %d offset %d: %v",
                        message.Topic, message.Partition, message.Offset, ctx.Err())
                return ctx.Err()</span>
        }
}

// App holds the application dependencies
type App struct {
        kafkaClient   sarama.Client
        kafkaHandler  *kafkaHandler.Handler
        kafkaProducer sarama.SyncProducer
        manager       *gomaint.Manager
        server        *http.Server
        topics        []string
}

func main() <span class="cov0" title="0">{
        fmt.Println("Kafka Service with Maintenance Mode")
        fmt.Println("==================================")

        app, err := setupApp()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to setup application: %v", err)
        }</span>

        // Setup graceful shutdown
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle shutdown signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                log.Println("Shutting down...")
                cancel()
        }</span>()

        // Start the application
        <span class="cov0" title="0">if err := app.run(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Application failed: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Application stopped")</span>
}

func setupApp() (*App, error) <span class="cov0" title="0">{
        // Get configuration from environment
        brokersStr := getEnv("KAFKA_BROKERS", "kafka:9092")
        topicsStr := getEnv("KAFKA_TOPICS", "test-topic,user-events,system-logs")
        consumerGroup := getEnv("KAFKA_CONSUMER_GROUP", "gomaint-consumer-group")
        etcdEndpoints := getEnv("ETCD_ENDPOINTS", "etcd:2379")

        brokers := strings.Split(brokersStr, ",")
        topics := strings.Split(topicsStr, ",")

        log.Printf("Configuring Kafka client for brokers: %v", brokers)
        log.Printf("Topics: %v, Consumer Group: %s", topics, consumerGroup)

        // Create message processor
        messageProcessor := &amp;MessageProcessor{
                logger: log.Default(),
        }

        // Create Kafka handler configuration
        config := kafkaHandler.DefaultConfig(brokers, topics, consumerGroup)
        config.DrainTimeout = 45 * time.Second // Allow more time for message draining
        config.MaxWorkers = 5
        config.SessionTimeout = 30 * time.Second
        config.HeartbeatInterval = 3 * time.Second
        config.OffsetInitial = sarama.OffsetOldest // Start from oldest unread messages

        // Create Kafka handler
        handler, err := kafkaHandler.NewKafkaHandler(brokers, config, messageProcessor, log.Default())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Kafka handler: %w", err)
        }</span>

        // Create Kafka producer for sending test messages
        <span class="cov0" title="0">producerConfig := sarama.NewConfig()
        producerConfig.Producer.Return.Successes = true
        producerConfig.Producer.RequiredAcks = sarama.WaitForAll
        producerConfig.Producer.Retry.Max = 3
        producerConfig.Producer.Compression = sarama.CompressionSnappy

        producer, err := sarama.NewSyncProducer(brokers, producerConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Kafka producer: %w", err)
        }</span>

        // Create maintenance manager using new simplified API
        <span class="cov0" title="0">mgr, err := gomaint.StartWithEtcd(
                context.Background(),
                strings.Split(etcdEndpoints, ","),
                "/maintenance/kafka-service",
                30*time.Second,
                handler, // Register handler during creation
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create maintenance manager: %w", err)
        }</span>

        // Setup HTTP server
        <span class="cov0" title="0">mux := http.NewServeMux()
        app := &amp;App{
                kafkaHandler:  handler,
                kafkaProducer: producer,
                manager:       mgr,
                topics:        topics,
                server: &amp;http.Server{
                        Addr:    ":8080",
                        Handler: mux,
                },
        }

        // Setup routes
        app.setupRoutes(mux)

        // Initialize topics (create if they don't exist)
        if err := app.initializeTopics(context.Background()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize topics: %w", err)
        }</span>

        // Send initial test messages
        <span class="cov0" title="0">if err := app.sendInitialMessages(context.Background()); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to send initial messages: %v", err)
                // Don't fail startup for this
        }</span>

        <span class="cov0" title="0">return app, nil</span>
}

func (app *App) initializeTopics(ctx context.Context) error <span class="cov0" title="0">{
        log.Println("Initializing Kafka topics...")

        // Get topic metadata (this will trigger topic creation if auto-create is enabled)
        metadata, err := app.kafkaHandler.GetTopicMetadata()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not get topic metadata: %v", err)
                return nil // Don't fail on this
        }</span>

        <span class="cov0" title="0">for topic, info := range metadata </span><span class="cov0" title="0">{
                log.Printf("Topic %s: %+v", topic, info)
        }</span>

        <span class="cov0" title="0">log.Println("Topic initialization completed")
        return nil</span>
}

func (app *App) sendInitialMessages(ctx context.Context) error <span class="cov0" title="0">{
        log.Println("Sending initial test messages to topics...")

        messages := []struct {
                topic   string
                message string
        }{
                {"test-topic", "Initial test message - " + time.Now().Format(time.RFC3339)},
                {"user-events", `{"event": "user_login", "user_id": "user123", "timestamp": "` + time.Now().Format(time.RFC3339) + `"}`},
                {"system-logs", `{"level": "info", "message": "Kafka service started", "timestamp": "` + time.Now().Format(time.RFC3339) + `"}`},
        }

        for _, msg := range messages </span><span class="cov0" title="0">{
                // Skip if topic is not in our configured topics
                found := false
                for _, configuredTopic := range app.topics </span><span class="cov0" title="0">{
                        if configuredTopic == msg.topic </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">kafkaMsg := &amp;sarama.ProducerMessage{
                        Topic: msg.topic,
                        Key:   sarama.StringEncoder("initial"),
                        Value: sarama.StringEncoder(msg.message),
                        Headers: []sarama.RecordHeader{
                                {
                                        Key:   []byte("source"),
                                        Value: []byte("kafka-service-init"),
                                },
                        },
                }

                partition, offset, err := app.kafkaProducer.SendMessage(kafkaMsg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to send initial message to topic %s: %w", msg.topic, err)
                }</span>
                <span class="cov0" title="0">log.Printf("Sent initial message to topic %s partition %d offset %d", msg.topic, partition, offset)</span>
        }

        <span class="cov0" title="0">log.Println("Successfully sent initial test messages")
        return nil</span>
}

func (app *App) setupRoutes(mux *http.ServeMux) <span class="cov0" title="0">{
        // Health check endpoint
        mux.HandleFunc("/health", app.healthHandler)

        // Kafka management endpoints
        mux.HandleFunc("/messages/send", app.sendMessageHandler)
        mux.HandleFunc("/messages/stats", app.statsHandler)

        // Topic management endpoints
        mux.HandleFunc("/topics/info", app.topicsInfoHandler)
}</span>

func (app *App) run(ctx context.Context) error <span class="cov0" title="0">{
        // Maintenance manager is already started by StartWithEtcd

        // Start Kafka message processing
        if err := app.kafkaHandler.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start Kafka handler: %w", err)
        }</span>

        // Start HTTP server
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Printf("Starting HTTP server on %s", app.server.Addr)
                if err := app.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("HTTP server failed: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">fmt.Printf("Server running on http://localhost:8083\\n")
        fmt.Println("Endpoints:")
        fmt.Println("  Health check: http://localhost:8083/health")
        fmt.Println("  Send message: http://localhost:8083/messages/send")
        fmt.Println("  Stats: http://localhost:8083/messages/stats")
        fmt.Println("  Topics info: http://localhost:8083/topics/info")
        fmt.Println()
        fmt.Println("To enable maintenance mode:")
        fmt.Println("  etcdctl --endpoints=localhost:2401 put /maintenance/kafka-service true")
        fmt.Println()
        fmt.Println("To disable maintenance mode:")
        fmt.Println("  etcdctl --endpoints=localhost:2401 put /maintenance/kafka-service false")
        fmt.Println()
        fmt.Println("Press Ctrl+C to stop...")

        // Wait for context cancellation
        &lt;-ctx.Done()

        // Graceful shutdown
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Stop Kafka handler
        app.kafkaHandler.Stop()

        // Close Kafka producer
        if app.kafkaProducer != nil </span><span class="cov0" title="0">{
                app.kafkaProducer.Close()
        }</span>

        // Close Kafka handler
        <span class="cov0" title="0">if app.kafkaHandler != nil </span><span class="cov0" title="0">{
                app.kafkaHandler.Close()
        }</span>

        // Stop maintenance manager
        <span class="cov0" title="0">app.manager.Stop()

        // Shutdown HTTP server
        return app.server.Shutdown(shutdownCtx)</span>
}

func (app *App) healthHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if app.manager.IsInMaintenance() </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.Header().Set("Retry-After", "60")
                w.WriteHeader(http.StatusServiceUnavailable)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "error":   "Service Unavailable",
                        "message": "Service is currently under maintenance. Please try again later.",
                        "code":    503,
                })
                return
        }</span>

        // Check handler health
        <span class="cov0" title="0">health := app.manager.GetHandlerHealth()
        allHealthy := true
        for _, healthy := range health </span><span class="cov0" title="0">{
                if !healthy </span><span class="cov0" title="0">{
                        allHealthy = false
                        break</span>
                }
        }

        <span class="cov0" title="0">status := "healthy"
        statusCode := http.StatusOK
        if !allHealthy </span><span class="cov0" title="0">{
                status = "unhealthy"
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "status":      status,
                "maintenance": app.manager.IsInMaintenance(),
                "handlers":    health,
                "topics":      app.topics,
                "timestamp":   time.Now().UTC(),
        })</span>
}

func (app *App) sendMessageHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var request struct {
                Topic   string `json:"topic"`
                Message string `json:"message"`
                Key     string `json:"key,omitempty"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // Default topic if not specified
        <span class="cov0" title="0">if request.Topic == "" </span><span class="cov0" title="0">{
                request.Topic = "test-topic"
        }</span>

        // Default message if not specified
        <span class="cov0" title="0">if request.Message == "" </span><span class="cov0" title="0">{
                request.Message = fmt.Sprintf("Test message sent at %s", time.Now().Format(time.RFC3339))
        }</span>

        // Default key if not specified
        <span class="cov0" title="0">if request.Key == "" </span><span class="cov0" title="0">{
                request.Key = "api-generated"
        }</span>

        // Check if topic is in our configured topics
        <span class="cov0" title="0">validTopic := false
        for _, topic := range app.topics </span><span class="cov0" title="0">{
                if topic == request.Topic </span><span class="cov0" title="0">{
                        validTopic = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !validTopic </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Topic %s is not configured. Available topics: %v", request.Topic, app.topics), http.StatusBadRequest)
                return
        }</span>

        // Send message to Kafka
        <span class="cov0" title="0">kafkaMsg := &amp;sarama.ProducerMessage{
                Topic: request.Topic,
                Key:   sarama.StringEncoder(request.Key),
                Value: sarama.StringEncoder(request.Message),
                Headers: []sarama.RecordHeader{
                        {
                                Key:   []byte("source"),
                                Value: []byte("kafka-service-api"),
                        },
                        {
                                Key:   []byte("timestamp"),
                                Value: []byte(time.Now().Format(time.RFC3339)),
                        },
                },
        }

        partition, offset, err := app.kafkaProducer.SendMessage(kafkaMsg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send message to topic %s: %v", request.Topic, err)
                http.Error(w, "Failed to send message", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "topic":     request.Topic,
                "partition": partition,
                "offset":    offset,
                "key":       request.Key,
                "message":   request.Message,
                "timestamp": time.Now().UTC(),
        })</span>
}

func (app *App) statsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get Kafka handler stats
        var kafkaStats map[string]interface{}
        if handler, exists := app.manager.GetHandler("kafka"); exists </span><span class="cov0" title="0">{
                if kh, ok := handler.(*kafkaHandler.Handler); ok </span><span class="cov0" title="0">{
                        kafkaStats = kh.GetStats()
                }</span>
        }

        <span class="cov0" title="0">stats := map[string]interface{}{
                "maintenance": app.manager.IsInMaintenance(),
                "timestamp":   time.Now().UTC(),
                "handlers":    app.manager.GetHandlerHealth(),
                "kafka":       kafkaStats,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

func (app *App) topicsInfoHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get topic metadata
        metadata, err := app.kafkaHandler.GetTopicMetadata()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get topic metadata: %v", err)
                http.Error(w, "Failed to get topic information", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "topics":    app.topics,
                "metadata":  metadata,
                "timestamp": time.Now().UTC(),
        })</span>
}

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "math/rand"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/sqs"
        "github.com/aws/aws-sdk-go-v2/service/sqs/types"

        "github.com/abhishekvarshney/gomaint"
        sqsHandler "github.com/abhishekvarshney/gomaint/pkg/handlers/sqs"
)

// MessageProcessor implements the SQS message processing logic
type MessageProcessor struct {
        logger *log.Logger
}

// ProcessMessage processes a single SQS message
func (mp *MessageProcessor) ProcessMessage(ctx context.Context, message types.Message) error <span class="cov0" title="0">{
        messageBody := aws.ToString(message.Body)
        messageId := aws.ToString(message.MessageId)

        mp.logger.Printf("Processing message %s: %s", messageId, messageBody)

        // Simulate processing time (1-3 seconds)
        processingTime := time.Duration(1+rand.Intn(3)) * time.Second

        // Check for context cancellation during processing
        timer := time.NewTimer(processingTime)
        defer timer.Stop()

        select </span>{
        case &lt;-timer.C:<span class="cov0" title="0">
                // Processing completed successfully
                mp.logger.Printf("Successfully processed message %s after %v", messageId, processingTime)
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                mp.logger.Printf("Processing cancelled for message %s: %v", messageId, ctx.Err())
                return ctx.Err()</span>
        }
}

// App holds the application dependencies
type App struct {
        sqsClient  *sqs.Client
        sqsHandler *sqsHandler.Handler
        manager    *gomaint.Manager
        server     *http.Server
        queueURL   string
}

func main() <span class="cov0" title="0">{
        fmt.Println("SQS Service with Maintenance Mode")
        fmt.Println("=================================")

        app, err := setupApp()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to setup application: %v", err)
        }</span>

        // Setup graceful shutdown
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle shutdown signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                log.Println("Shutting down...")
                cancel()
        }</span>()

        // Start the application
        <span class="cov0" title="0">if err := app.run(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Application failed: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Application stopped")</span>
}

func setupApp() (*App, error) <span class="cov0" title="0">{
        // Get configuration from environment
        queueURL := getEnv("SQS_QUEUE_URL", "http://localstack:4566/000000000000/test-queue")
        etcdEndpoints := getEnv("ETCD_ENDPOINTS", "etcd:2379")
        awsEndpoint := getEnv("AWS_ENDPOINT", "http://localstack:4566")
        awsRegion := getEnv("AWS_REGION", "us-east-1")

        log.Printf("Configuring SQS client for queue: %s", queueURL)
        log.Printf("AWS endpoint: %s, region: %s", awsEndpoint, awsRegion)

        // Configure AWS SDK for LocalStack
        cfg, err := config.LoadDefaultConfig(context.TODO(),
                config.WithRegion(awsRegion),
                config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(
                        "test", "test", "", // LocalStack accepts any credentials
                )),
                config.WithEndpointResolverWithOptions(aws.EndpointResolverWithOptionsFunc(
                        func(service, region string, options ...interface{}) (aws.Endpoint, error) </span><span class="cov0" title="0">{
                                return aws.Endpoint{
                                        URL:           awsEndpoint,
                                        SigningRegion: awsRegion,
                                }, nil
                        }</span>,
                )),
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load AWS config: %w", err)
        }</span>

        // Create SQS client
        <span class="cov0" title="0">sqsClient := sqs.NewFromConfig(cfg)

        // Create message processor
        messageProcessor := &amp;MessageProcessor{
                logger: log.Default(),
        }

        // Create SQS handler configuration
        sqsConfig := sqsHandler.DefaultConfig(queueURL)
        sqsConfig.DrainTimeout = 45 * time.Second // Allow more time for message draining
        sqsConfig.MaxNumberOfMessages = 5
        sqsConfig.WaitTimeSeconds = 10

        // Create SQS handler
        handler := sqsHandler.NewSQSHandler(sqsClient, sqsConfig, messageProcessor, log.Default())

        // Create maintenance manager using new simplified API
        mgr, err := gomaint.StartWithEtcd(
                context.Background(),
                strings.Split(etcdEndpoints, ","),
                "/maintenance/sqs-service",
                30*time.Second,
                handler, // Register handler during creation
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create maintenance manager: %w", err)
        }</span>

        // Setup HTTP server
        <span class="cov0" title="0">mux := http.NewServeMux()
        app := &amp;App{
                sqsClient:  sqsClient,
                sqsHandler: handler,
                manager:    mgr,
                queueURL:   queueURL,
                server: &amp;http.Server{
                        Addr:    ":8080",
                        Handler: mux,
                },
        }

        // Setup routes
        app.setupRoutes(mux)

        // Initialize queue (create if it doesn't exist)
        if err := app.initializeQueue(context.Background()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize queue: %w", err)
        }</span>

        // Send initial test messages
        <span class="cov0" title="0">if err := app.sendInitialMessages(context.Background()); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to send initial messages: %v", err)
                // Don't fail startup for this
        }</span>

        <span class="cov0" title="0">return app, nil</span>
}

func (app *App) initializeQueue(ctx context.Context) error <span class="cov0" title="0">{
        // Extract queue name from URL (LocalStack format)
        queueName := "test-queue"
        if parts := strings.Split(app.queueURL, "/"); len(parts) &gt; 0 </span><span class="cov0" title="0">{
                queueName = parts[len(parts)-1]
        }</span>

        // Try to create the queue (idempotent operation)
        <span class="cov0" title="0">_, err := app.sqsClient.CreateQueue(ctx, &amp;sqs.CreateQueueInput{
                QueueName: aws.String(queueName),
                Attributes: map[string]string{
                        "VisibilityTimeout":      "30",
                        "MessageRetentionPeriod": "1209600", // 14 days
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                // Queue might already exist, which is fine
                log.Printf("Queue creation result: %v (queue might already exist)", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Queue %s created successfully", queueName)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (app *App) sendInitialMessages(ctx context.Context) error <span class="cov0" title="0">{
        log.Println("Sending initial test messages to queue...")

        for i := 1; i &lt;= 3; i++ </span><span class="cov0" title="0">{
                message := fmt.Sprintf("Initial test message %d - %s", i, time.Now().Format(time.RFC3339))
                _, err := app.sqsClient.SendMessage(ctx, &amp;sqs.SendMessageInput{
                        QueueUrl:    aws.String(app.queueURL),
                        MessageBody: aws.String(message),
                })

                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to send initial message %d: %w", i, err)
                }</span>
                <span class="cov0" title="0">log.Printf("Sent initial message %d", i)</span>
        }

        <span class="cov0" title="0">log.Println("Successfully sent initial test messages")
        return nil</span>
}

func (app *App) setupRoutes(mux *http.ServeMux) <span class="cov0" title="0">{
        // Health check endpoint
        mux.HandleFunc("/health", app.healthHandler)

        // SQS management endpoints
        mux.HandleFunc("/messages/send", app.sendMessageHandler)
        mux.HandleFunc("/messages/stats", app.statsHandler)

        // Queue management endpoints
        mux.HandleFunc("/queue/info", app.queueInfoHandler)
}</span>

func (app *App) run(ctx context.Context) error <span class="cov0" title="0">{
        // Maintenance manager is already started by StartWithEtcd

        // Start SQS message processing
        if err := app.sqsHandler.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start SQS handler: %w", err)
        }</span>

        // Start HTTP server
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Printf("Starting HTTP server on %s", app.server.Addr)
                if err := app.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("HTTP server failed: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">fmt.Printf("Server running on http://localhost:8082\n")
        fmt.Println("Endpoints:")
        fmt.Println("  Health check: http://localhost:8082/health")
        fmt.Println("  Send message: http://localhost:8082/messages/send")
        fmt.Println("  Stats: http://localhost:8082/messages/stats")
        fmt.Println("  Queue info: http://localhost:8082/queue/info")
        fmt.Println()
        fmt.Println("To enable maintenance mode:")
        fmt.Println("  etcdctl --endpoints=localhost:2399 put /maintenance/sqs-service true")
        fmt.Println()
        fmt.Println("To disable maintenance mode:")
        fmt.Println("  etcdctl --endpoints=localhost:2399 put /maintenance/sqs-service false")
        fmt.Println()
        fmt.Println("Press Ctrl+C to stop...")

        // Wait for context cancellation
        &lt;-ctx.Done()

        // Graceful shutdown
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Stop SQS handler
        app.sqsHandler.Stop()

        // Stop maintenance manager
        app.manager.Stop()

        // Shutdown HTTP server
        return app.server.Shutdown(shutdownCtx)</span>
}

func (app *App) healthHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if app.manager.IsInMaintenance() </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.Header().Set("Retry-After", "60")
                w.WriteHeader(http.StatusServiceUnavailable)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "error":   "Service Unavailable",
                        "message": "Service is currently under maintenance. Please try again later.",
                        "code":    503,
                })
                return
        }</span>

        // Check handler health
        <span class="cov0" title="0">health := app.manager.GetHandlerHealth()
        allHealthy := true
        for _, healthy := range health </span><span class="cov0" title="0">{
                if !healthy </span><span class="cov0" title="0">{
                        allHealthy = false
                        break</span>
                }
        }

        <span class="cov0" title="0">status := "healthy"
        statusCode := http.StatusOK
        if !allHealthy </span><span class="cov0" title="0">{
                status = "unhealthy"
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "status":      status,
                "maintenance": app.manager.IsInMaintenance(),
                "handlers":    health,
                "queue_url":   app.queueURL,
                "timestamp":   time.Now().UTC(),
        })</span>
}

func (app *App) sendMessageHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var request struct {
                Message string `json:"message"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if request.Message == "" </span><span class="cov0" title="0">{
                request.Message = fmt.Sprintf("Test message sent at %s", time.Now().Format(time.RFC3339))
        }</span>

        // Send message to SQS
        <span class="cov0" title="0">result, err := app.sqsClient.SendMessage(r.Context(), &amp;sqs.SendMessageInput{
                QueueUrl:    aws.String(app.queueURL),
                MessageBody: aws.String(request.Message),
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send message: %v", err)
                http.Error(w, "Failed to send message", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "message_id": aws.ToString(result.MessageId),
                "message":    request.Message,
                "queue_url":  app.queueURL,
                "timestamp":  time.Now().UTC(),
        })</span>
}

func (app *App) statsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get SQS handler stats
        var sqsStats map[string]interface{}
        if handler, exists := app.manager.GetHandler("sqs"); exists </span><span class="cov0" title="0">{
                if sqsHandler, ok := handler.(*sqsHandler.Handler); ok </span><span class="cov0" title="0">{
                        sqsStats = sqsHandler.GetStats()
                }</span>
        }

        <span class="cov0" title="0">stats := map[string]interface{}{
                "maintenance": app.manager.IsInMaintenance(),
                "timestamp":   time.Now().UTC(),
                "handlers":    app.manager.GetHandlerHealth(),
                "sqs":         sqsStats,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

func (app *App) queueInfoHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get queue attributes
        result, err := app.sqsClient.GetQueueAttributes(r.Context(), &amp;sqs.GetQueueAttributesInput{
                QueueUrl: aws.String(app.queueURL),
                AttributeNames: []types.QueueAttributeName{
                        types.QueueAttributeNameApproximateNumberOfMessages,
                        types.QueueAttributeNameApproximateNumberOfMessagesNotVisible,
                        types.QueueAttributeNameVisibilityTimeout,
                        types.QueueAttributeNameCreatedTimestamp,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get queue attributes: %v", err)
                http.Error(w, "Failed to get queue information", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "queue_url":  app.queueURL,
                "attributes": result.Attributes,
                "timestamp":  time.Now().UTC(),
        })</span>
}

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "strconv"
        "syscall"
        "time"

        "github.com/abhishekvarshney/gomaint"
        "github.com/abhishekvarshney/gomaint/pkg/handlers/database"
        _ "github.com/lib/pq"
        "xorm.io/xorm"
)

// User model for XORM
type User struct {
        ID        int64     `xorm:"pk autoincr" json:"id"`
        Name      string    `xorm:"varchar(255) not null" json:"name"`
        Email     string    `xorm:"varchar(255) unique not null" json:"email"`
        CreatedAt time.Time `xorm:"created" json:"created_at"`
        UpdatedAt time.Time `xorm:"updated" json:"updated_at"`
}

// TableName returns the table name for XORM
func (User) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>

// XormWrapper wraps the XORM engine to match our database interface
type XormWrapper struct {
        engine *xorm.Engine
}

// DB returns the underlying sql.DB from XORM engine
func (x *XormWrapper) DB() (*sql.DB, error) <span class="cov0" title="0">{
        return x.engine.DB().DB, nil
}</span>

// App holds the application dependencies
type App struct {
        engine  *xorm.Engine
        manager *gomaint.Manager
        server  *http.Server
}

func main() <span class="cov0" title="0">{
        fmt.Println("XORM Service with Maintenance Mode")
        fmt.Println("==================================")

        app, err := setupApp()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to setup application: %v", err)
        }</span>

        // Setup graceful shutdown
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle shutdown signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                log.Println("Shutting down...")
                cancel()
        }</span>()

        // Start the application
        <span class="cov0" title="0">if err := app.run(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Application failed: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Application stopped")</span>
}

func setupApp() (*App, error) <span class="cov0" title="0">{
        host := getEnv("DB_HOST", "postgres")
        port := 5432
        user := "postgres"
        password := "postgres"
        dbname := getEnv("DB_NAME", "xormdb")
        sslmode := "disable"

        // Construct the connection string (DSN)
        dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                host, port, user, password, dbname, sslmode)

        log.Printf("Connecting to database: host=%s, port=%d, dbname=%s", host, port, dbname)

        // Create XORM engine
        engine, err := xorm.NewEngine("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create XORM engine: %w", err)
        }</span>

        // Enable SQL logging (optional)
        <span class="cov0" title="0">engine.ShowSQL(true)

        // Sync the schema (create tables if they don't exist)
        if err := engine.Sync2(new(User)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sync database schema: %w", err)
        }</span>

        // Insert sample data if table is empty
        <span class="cov0" title="0">if err := insertSampleData(engine); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to insert sample data: %v", err)
                // Don't fail the startup for this
        }</span>

        // Create XORM database handler using the generic database handler
        <span class="cov0" title="0">xormWrapper := &amp;XormWrapper{engine: engine}
        xormHandler := database.NewDatabaseHandler("xorm", xormWrapper, 30*time.Second, log.Default())

        // Create maintenance manager using new simplified API
        endpoints := []string{getEnv("ETCD_ENDPOINTS", "localhost:2379")}
        mgr, err := gomaint.StartWithEtcd(
                context.Background(),
                endpoints,
                "/maintenance/xorm-service",
                30*time.Second,
                xormHandler, // Register handler during creation
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create maintenance manager: %w", err)
        }</span>

        // Setup HTTP server
        <span class="cov0" title="0">mux := http.NewServeMux()
        app := &amp;App{
                engine:  engine,
                manager: mgr,
                server: &amp;http.Server{
                        Addr:    ":8080",
                        Handler: mux,
                },
        }

        // Setup routes
        app.setupRoutes(mux)

        return app, nil</span>
}

func (app *App) setupRoutes(mux *http.ServeMux) <span class="cov0" title="0">{
        // Health check endpoint
        mux.HandleFunc("/health", app.healthHandler)

        // User CRUD endpoints
        mux.HandleFunc("/users", app.usersHandler)
        mux.HandleFunc("/users/", app.userHandler)

        // Stats endpoint
        mux.HandleFunc("/stats", app.statsHandler)
}</span>

func (app *App) run(ctx context.Context) error <span class="cov0" title="0">{
        // Maintenance manager is already started by StartWithEtcd

        // Start HTTP server
        go func() </span><span class="cov0" title="0">{
                log.Printf("Starting HTTP server on %s", app.server.Addr)
                if err := app.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("HTTP server failed: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">fmt.Printf("Server running on http://localhost:8081\n")
        fmt.Println("Endpoints:")
        fmt.Println("  Health check: http://localhost:8081/health")
        fmt.Println("  Users API: http://localhost:8081/users")
        fmt.Println("  Stats: http://localhost:8081/stats")
        fmt.Println()
        fmt.Println("To enable maintenance mode:")
        fmt.Println("  etcdctl put /maintenance/xorm-service true")
        fmt.Println()
        fmt.Println("To disable maintenance mode:")
        fmt.Println("  etcdctl put /maintenance/xorm-service false")
        fmt.Println()
        fmt.Println("Press Ctrl+C to stop...")

        // Wait for context cancellation
        &lt;-ctx.Done()

        // Graceful shutdown
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Stop maintenance manager
        app.manager.Stop()

        // Close XORM engine
        app.engine.Close()

        // Shutdown HTTP server
        return app.server.Shutdown(shutdownCtx)</span>
}

func (app *App) healthHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if app.manager.IsInMaintenance() </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.Header().Set("Retry-After", "60")
                w.WriteHeader(http.StatusServiceUnavailable)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "error":   "Service Unavailable",
                        "message": "Service is currently under maintenance. Please try again later.",
                        "code":    503,
                })
                return
        }</span>

        // Check database health
        <span class="cov0" title="0">health := app.manager.GetHandlerHealth()
        allHealthy := true
        for _, healthy := range health </span><span class="cov0" title="0">{
                if !healthy </span><span class="cov0" title="0">{
                        allHealthy = false
                        break</span>
                }
        }

        <span class="cov0" title="0">status := "healthy"
        statusCode := http.StatusOK
        if !allHealthy </span><span class="cov0" title="0">{
                status = "unhealthy"
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "status":      status,
                "maintenance": app.manager.IsInMaintenance(),
                "handlers":    health,
                "timestamp":   time.Now().UTC(),
        })</span>
}

func (app *App) usersHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if app.manager.IsInMaintenance() </span><span class="cov0" title="0">{
                http.Error(w, "Service under maintenance", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov0" title="0">switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                app.listUsers(w, r)</span>
        case http.MethodPost:<span class="cov0" title="0">
                app.createUser(w, r)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

func (app *App) userHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if app.manager.IsInMaintenance() </span><span class="cov0" title="0">{
                http.Error(w, "Service under maintenance", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov0" title="0">switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                app.getUser(w, r)</span>
        case http.MethodPut:<span class="cov0" title="0">
                app.updateUser(w, r)</span>
        case http.MethodDelete:<span class="cov0" title="0">
                app.deleteUser(w, r)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

func (app *App) listUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var users []User
        if err := app.engine.Find(&amp;users); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to fetch users: %v", err)
                http.Error(w, "Failed to fetch users", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(users)</span>
}

func (app *App) createUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var user User
        if err := json.NewDecoder(r.Body).Decode(&amp;user); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // XORM will automatically set created_at and updated_at
        <span class="cov0" title="0">affected, err := app.engine.Insert(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create user: %v", err)
                http.Error(w, "Failed to create user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if affected == 0 </span><span class="cov0" title="0">{
                http.Error(w, "Failed to create user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(user)</span>
}

func (app *App) getUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Simple ID extraction - in production use proper routing
        idStr := r.URL.Path[len("/users/"):]
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var user User
        has, err := app.engine.ID(id).Get(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to fetch user: %v", err)
                http.Error(w, "Failed to fetch user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !has </span><span class="cov0" title="0">{
                http.Error(w, "User not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)</span>
}

func (app *App) updateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idStr := r.URL.Path[len("/users/"):]
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var updates User
        if err := json.NewDecoder(r.Body).Decode(&amp;updates); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // XORM will automatically set updated_at
        <span class="cov0" title="0">affected, err := app.engine.ID(id).Cols("name", "email").Update(&amp;updates)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update user: %v", err)
                http.Error(w, "Failed to update user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if affected == 0 </span><span class="cov0" title="0">{
                http.Error(w, "User not found", http.StatusNotFound)
                return
        }</span>

        // Fetch the updated user
        <span class="cov0" title="0">var user User
        has, err := app.engine.ID(id).Get(&amp;user)
        if err != nil || !has </span><span class="cov0" title="0">{
                log.Printf("Failed to fetch updated user: %v", err)
                http.Error(w, "Failed to fetch updated user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)</span>
}

func (app *App) deleteUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idStr := r.URL.Path[len("/users/"):]
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">affected, err := app.engine.ID(id).Delete(&amp;User{})
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to delete user: %v", err)
                http.Error(w, "Failed to delete user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if affected == 0 </span><span class="cov0" title="0">{
                http.Error(w, "User not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (app *App) statsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get XORM handler stats
        var xormStats map[string]interface{}
        if handler, exists := app.manager.GetHandler("xorm"); exists </span><span class="cov0" title="0">{
                if xormHandler, ok := handler.(*database.Handler); ok </span><span class="cov0" title="0">{
                        xormStats = xormHandler.GetStats()
                }</span>
        }

        <span class="cov0" title="0">stats := map[string]interface{}{
                "maintenance": app.manager.IsInMaintenance(),
                "timestamp":   time.Now().UTC(),
                "handlers":    app.manager.GetHandlerHealth(),
                "xorm":        xormStats,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

func insertSampleData(engine *xorm.Engine) error <span class="cov0" title="0">{
        // Check if we already have data
        count, err := engine.Count(&amp;User{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to count existing users: %w", err)
        }</span>

        // Only insert if table is empty
        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("Users table already has %d records, skipping sample data insertion", count)
                return nil
        }</span>

        // Insert sample users
        <span class="cov0" title="0">sampleUsers := []User{
                {Name: "Alice Johnson", Email: "alice@example.com"},
                {Name: "Charlie Brown", Email: "charlie@example.com"},
                {Name: "Diana Prince", Email: "diana@example.com"},
        }

        affected, err := engine.Insert(&amp;sampleUsers)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert sample data: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Inserted %d sample users", affected)
        return nil</span>
}

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package gomaint provides a maintenance library for Go services
// that can gracefully handle maintenance mode.
package gomaint

import (
        "context"
        "time"

        "github.com/abhishekvarshney/gomaint/pkg/eventsource"
        "github.com/abhishekvarshney/gomaint/pkg/handlers"
        "github.com/abhishekvarshney/gomaint/pkg/maintenance"
)

// Manager is the maintenance manager
type Manager = maintenance.Manager

// Handler interface for maintenance handlers
type Handler = handlers.Handler

// StartWithEtcd creates and starts a maintenance manager with etcd event source
// This is the recommended and primary way to create a maintenance manager.
func StartWithEtcd(ctx context.Context, endpoints []string, keyPath string, drainTimeout time.Duration, handlers ...Handler) (*Manager, error) <span class="cov0" title="0">{
        // Create etcd configuration
        etcdConfig := eventsource.NewEtcdConfig("etcd", endpoints, keyPath)

        // Create etcd event source
        eventSource, err := eventsource.NewEtcdEventSource(etcdConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create maintenance manager
        <span class="cov0" title="0">mgr := maintenance.NewManager(eventSource, drainTimeout)

        // Register all handlers
        for _, handler := range handlers </span><span class="cov0" title="0">{
                if err := mgr.RegisterHandler(handler); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Start the manager
        <span class="cov0" title="0">if err := mgr.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return mgr, nil</span>
}

// HandlerState represents the current state of a handler
type HandlerState = handlers.HandlerState

// Handler states
const (
        StateNormal      = handlers.StateNormal
        StateMaintenance = handlers.StateMaintenance
        StateError       = handlers.StateError
)
</pre>
		
		<pre class="file" id="file13" style="display: none">package eventsource

import (
        "context"
        "crypto/tls"
        "fmt"
        "strings"
        "sync"
        "time"

        clientv3 "go.etcd.io/etcd/client/v3"
)

// EtcdConfig holds etcd-specific configuration
type EtcdConfig struct {
        Config

        // Endpoints is the list of etcd endpoints
        Endpoints []string `json:"endpoints"`

        // KeyPath is the etcd key to watch for maintenance state
        KeyPath string `json:"key_path"`

        // Timeout for etcd operations
        Timeout time.Duration `json:"timeout"`

        // Authentication
        Username string `json:"username,omitempty"`
        Password string `json:"password,omitempty"`

        // TLS Configuration
        TLS      bool   `json:"tls,omitempty"`
        CertFile string `json:"cert_file,omitempty"`
        KeyFile  string `json:"key_file,omitempty"`
        CAFile   string `json:"ca_file,omitempty"`
}

// NewEtcdConfig creates a new etcd configuration
func NewEtcdConfig(name string, endpoints []string, keyPath string) *EtcdConfig <span class="cov8" title="1">{
        return &amp;EtcdConfig{
                Config: Config{
                        Name: name,
                        Type: "etcd",
                },
                Endpoints: endpoints,
                KeyPath:   keyPath,
                Timeout:   5 * time.Second,
        }
}</span>

// EtcdEventSource implements EventSource for etcd
type EtcdEventSource struct {
        config  *EtcdConfig
        client  *clientv3.Client
        handler EventHandler
        ctx     context.Context
        cancel  context.CancelFunc
        healthy bool
        mutex   sync.RWMutex
}

// NewEtcdEventSource creates a new etcd event source
func NewEtcdEventSource(config *EtcdConfig) (*EtcdEventSource, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("config cannot be nil")
        }</span>

        <span class="cov8" title="1">if len(config.Endpoints) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("at least one etcd endpoint must be specified")
        }</span>

        <span class="cov8" title="1">if config.KeyPath == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("key path must be specified")
        }</span>

        <span class="cov8" title="1">if config.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                config.Timeout = 5 * time.Second
        }</span>

        <span class="cov8" title="1">return &amp;EtcdEventSource{
                config:  config,
                healthy: false,
        }, nil</span>
}

// Start begins monitoring for maintenance events
func (e *EtcdEventSource) Start(ctx context.Context, handler EventHandler) error <span class="cov0" title="0">{
        if handler == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event handler cannot be nil")
        }</span>

        <span class="cov0" title="0">e.mutex.Lock()
        defer e.mutex.Unlock()

        if e.client != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event source already started")
        }</span>

        // Create etcd client
        <span class="cov0" title="0">clientConfig := clientv3.Config{
                Endpoints:   e.config.Endpoints,
                DialTimeout: e.config.Timeout,
                Username:    e.config.Username,
                Password:    e.config.Password,
        }

        // Configure TLS if enabled
        if e.config.TLS </span><span class="cov0" title="0">{
                tlsConfig := &amp;tls.Config{
                        InsecureSkipVerify: false,
                }

                if e.config.CertFile != "" &amp;&amp; e.config.KeyFile != "" </span><span class="cov0" title="0">{
                        cert, err := tls.LoadX509KeyPair(e.config.CertFile, e.config.KeyFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to load client certificates: %w", err)
                        }</span>
                        <span class="cov0" title="0">tlsConfig.Certificates = []tls.Certificate{cert}</span>
                }

                <span class="cov0" title="0">clientConfig.TLS = tlsConfig</span>
        }

        <span class="cov0" title="0">client, err := clientv3.New(clientConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create etcd client: %w", err)
        }</span>

        <span class="cov0" title="0">e.client = client
        e.handler = handler
        e.ctx, e.cancel = context.WithCancel(ctx)

        // Check initial state
        if err := e.checkInitialState(); err != nil </span><span class="cov0" title="0">{
                e.cleanup()
                return fmt.Errorf("failed to check initial state: %w", err)
        }</span>

        // Start watching for changes
        <span class="cov0" title="0">go e.watchForChanges()

        e.healthy = true
        return nil</span>
}

// Stop stops monitoring and cleans up resources
func (e *EtcdEventSource) Stop() error <span class="cov0" title="0">{
        e.mutex.Lock()
        defer e.mutex.Unlock()

        e.cleanup()
        return nil
}</span>

// cleanup performs internal cleanup (must be called with mutex held)
func (e *EtcdEventSource) cleanup() <span class="cov0" title="0">{
        e.healthy = false

        if e.cancel != nil </span><span class="cov0" title="0">{
                e.cancel()
                e.cancel = nil
        }</span>

        <span class="cov0" title="0">if e.client != nil </span><span class="cov0" title="0">{
                e.client.Close()
                e.client = nil
        }</span>

        <span class="cov0" title="0">e.handler = nil</span>
}

// Name returns the name of this event source
func (e *EtcdEventSource) Name() string <span class="cov8" title="1">{
        return e.config.Name
}</span>

// Type returns the type of event source
func (e *EtcdEventSource) Type() string <span class="cov8" title="1">{
        return e.config.Type
}</span>

// IsHealthy returns true if the event source is operational
func (e *EtcdEventSource) IsHealthy() bool <span class="cov8" title="1">{
        e.mutex.RLock()
        defer e.mutex.RUnlock()
        return e.healthy
}</span>

// SetMaintenance sets the maintenance state in etcd
func (e *EtcdEventSource) SetMaintenance(ctx context.Context, enabled bool) error <span class="cov0" title="0">{
        e.mutex.RLock()
        client := e.client
        e.mutex.RUnlock()

        if client == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event source not started")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, e.config.Timeout)
        defer cancel()

        value := "false"
        if enabled </span><span class="cov0" title="0">{
                value = "true"
        }</span>

        <span class="cov0" title="0">_, err := client.Put(ctx, e.config.KeyPath, value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set maintenance state: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetMaintenance gets the current maintenance state from etcd
func (e *EtcdEventSource) GetMaintenance(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        e.mutex.RLock()
        client := e.client
        e.mutex.RUnlock()

        if client == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("event source not started")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, e.config.Timeout)
        defer cancel()

        resp, err := client.Get(ctx, e.config.KeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get maintenance state: %w", err)
        }</span>

        <span class="cov0" title="0">if len(resp.Kvs) == 0 </span><span class="cov0" title="0">{
                return false, nil // Key doesn't exist, not in maintenance
        }</span>

        <span class="cov0" title="0">return e.parseMaintenanceValue(string(resp.Kvs[0].Value)), nil</span>
}

// checkInitialState checks the initial maintenance state
func (e *EtcdEventSource) checkInitialState() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(e.ctx, e.config.Timeout)
        defer cancel()

        resp, err := e.client.Get(ctx, e.config.KeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get initial key value: %w", err)
        }</span>

        // Determine initial state
        <span class="cov0" title="0">enabled := false
        if len(resp.Kvs) &gt; 0 </span><span class="cov0" title="0">{
                enabled = e.parseMaintenanceValue(string(resp.Kvs[0].Value))
        }</span>

        // Create and send initial event
        <span class="cov0" title="0">eventType := MaintenanceDisabled
        if enabled </span><span class="cov0" title="0">{
                eventType = MaintenanceEnabled
        }</span>

        <span class="cov0" title="0">event := MaintenanceEvent{
                Type:      eventType,
                Key:       e.config.KeyPath,
                Timestamp: time.Now(),
                Source:    e.config.Name,
                Metadata: map[string]interface{}{
                        "initial": true,
                },
        }

        return e.handler(event)</span>
}

// watchForChanges watches the etcd key for changes
func (e *EtcdEventSource) watchForChanges() <span class="cov0" title="0">{
        watchChan := e.client.Watch(e.ctx, e.config.KeyPath)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case watchResp := &lt;-watchChan:<span class="cov0" title="0">
                        if watchResp.Err() != nil </span><span class="cov0" title="0">{
                                // Mark as unhealthy but continue trying
                                e.mutex.Lock()
                                e.healthy = false
                                e.mutex.Unlock()

                                // Simple backoff - in production might want exponential backoff
                                time.Sleep(time.Second)
                                continue</span>
                        }

                        <span class="cov0" title="0">e.mutex.Lock()
                        e.healthy = true
                        e.mutex.Unlock()

                        for _, etcdEvent := range watchResp.Events </span><span class="cov0" title="0">{
                                if err := e.processEtcdEvent(etcdEvent); err != nil </span><span class="cov0" title="0">{
                                        // Log error but continue processing
                                        // In production, you might want to implement retry logic
                                        continue</span>
                                }
                        }
                }
        }
}

// processEtcdEvent processes a single etcd event
func (e *EtcdEventSource) processEtcdEvent(etcdEvent *clientv3.Event) error <span class="cov0" title="0">{
        var eventType EventType
        var enabled bool

        switch etcdEvent.Type </span>{
        case clientv3.EventTypePut:<span class="cov0" title="0">
                enabled = e.parseMaintenanceValue(string(etcdEvent.Kv.Value))</span>
        case clientv3.EventTypeDelete:<span class="cov0" title="0">
                enabled = false</span> // Key deleted means not in maintenance
        default:<span class="cov0" title="0">
                return nil</span> // Unknown event type, ignore
        }

        <span class="cov0" title="0">if enabled </span><span class="cov0" title="0">{
                eventType = MaintenanceEnabled
        }</span> else<span class="cov0" title="0"> {
                eventType = MaintenanceDisabled
        }</span>

        <span class="cov0" title="0">event := MaintenanceEvent{
                Type:      eventType,
                Key:       e.config.KeyPath,
                Timestamp: time.Now(),
                Source:    e.config.Name,
                Metadata: map[string]interface{}{
                        "etcd_event_type": etcdEvent.Type.String(),
                        "etcd_revision":   etcdEvent.Kv.ModRevision,
                },
        }

        return e.handler(event)</span>
}

// parseMaintenanceValue parses the etcd value to determine maintenance state
func (e *EtcdEventSource) parseMaintenanceValue(value string) bool <span class="cov8" title="1">{
        value = strings.ToLower(strings.TrimSpace(value))
        switch value </span>{
        case "true", "1", "yes", "on", "enabled", "maintenance":<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/abhishekvarshney/gomaint/pkg/handlers"
)

// DB interface for database operations (allows for easier testing)
// Compatible with GORM, XORM, and other ORM libraries that expose sql.DB
type DB interface {
        DB() (*sql.DB, error)
}

// ConnectionSettings holds the original database connection settings
type ConnectionSettings struct {
        MaxIdleCons     int
        MaxOpenCons     int
        ConnMaxLifetime time.Duration
        ConnMaxIdleTime time.Duration
}

// Handler implements the Handler interface for database operations
// Works with any ORM that provides access to the underlying sql.DB
type Handler struct {
        *handlers.BaseHandler
        db                DB
        logger            *log.Logger
        originalSettings  *ConnectionSettings
        settingsMux       sync.RWMutex
        drainTimeout      time.Duration
        activeConnections int32 // atomic counter for active connections
}

// NewDatabaseHandler creates a new database handler
// Compatible with GORM, XORM, and other ORM libraries
func NewDatabaseHandler(name string, db DB, drainTimeout time.Duration, logger *log.Logger) *Handler <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.Default()
        }</span>
        <span class="cov0" title="0">return &amp;Handler{
                BaseHandler:  handlers.NewBaseHandler(name),
                db:           db,
                logger:       logger,
                drainTimeout: drainTimeout,
        }</span>
}

// SetOriginalSettings allows manual configuration of the original connection settings
// This is useful when you want to override the defaults that would be used for restoration
func (h *Handler) SetOriginalSettings(settings *ConnectionSettings) <span class="cov0" title="0">{
        h.settingsMux.Lock()
        defer h.settingsMux.Unlock()
        h.originalSettings = settings
        h.logger.Printf("Database Handler (%s): Manual original settings configured - MaxIdle: %d, MaxOpen: %d",
                h.Name(), settings.MaxIdleCons, settings.MaxOpenCons)
}</span>

// cacheCurrentSettings stores the current database connection settings
func (h *Handler) cacheCurrentSettings(sqlDB *sql.DB) error <span class="cov0" title="0">{
        h.settingsMux.Lock()
        defer h.settingsMux.Unlock()

        // Only cache if we haven't already cached the original settings
        if h.originalSettings != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get current stats to determine current settings
        <span class="cov0" title="0">stats := sqlDB.Stats()

        // Note: Go's sql.DB doesn't expose current MaxIdleCons, ConnMaxLifetime, and ConnMaxIdleTime
        // We can only get MaxOpenConnections from stats. For the others, we'll use reasonable defaults
        // that are commonly used in production applications
        h.originalSettings = &amp;ConnectionSettings{
                MaxIdleCons:     2, // Common default for MaxIdleCons
                MaxOpenCons:     stats.MaxOpenConnections,
                ConnMaxLifetime: time.Hour,        // Common default
                ConnMaxIdleTime: 30 * time.Minute, // Common default
        }

        // If MaxOpenConnections is 0 (unlimited), use a reasonable default
        if h.originalSettings.MaxOpenCons == 0 </span><span class="cov0" title="0">{
                h.originalSettings.MaxOpenCons = 100 // Reasonable default for unlimited
        }</span>

        <span class="cov0" title="0">h.logger.Printf("Database Handler (%s): Cached original settings - MaxOpen: %d (MaxIdle and timeouts use defaults)",
                h.Name(), h.originalSettings.MaxOpenCons)

        return nil</span>
}

// OnMaintenanceStart handles maintenance mode activation
func (h *Handler) OnMaintenanceStart(ctx context.Context) error <span class="cov0" title="0">{
        h.logger.Printf("Database Handler (%s): Maintenance mode enabled - Preparing database for maintenance", h.Name())
        h.SetState(handlers.StateMaintenance)

        // Get database connection
        sqlDB, err := h.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                h.SetState(handlers.StateError)
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        // Cache current settings before modifying them
        <span class="cov0" title="0">if err := h.cacheCurrentSettings(sqlDB); err != nil </span><span class="cov0" title="0">{
                h.SetState(handlers.StateError)
                return fmt.Errorf("failed to cache current settings: %w", err)
        }</span>

        // Set minimum possible connection pool settings during maintenance
        // These are the absolute minimum values to reduce database load
        <span class="cov0" title="0">sqlDB.SetMaxIdleConns(0)                      // No idle connections
        sqlDB.SetMaxOpenConns(1)                      // Only 1 connection maximum
        sqlDB.SetConnMaxLifetime(h.drainTimeout / 10) // Short lifetime relative to drain timeout
        sqlDB.SetConnMaxIdleTime(h.drainTimeout / 10) // Short idle time relative to drain timeout

        // Wait for active connections to drain or timeout
        h.logger.Printf("Database Handler (%s): Waiting for active connections to drain (timeout: %v)", h.Name(), h.drainTimeout)

        drainStart := time.Now()
        ticker := time.NewTicker(time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-time.After(h.drainTimeout):<span class="cov0" title="0">
                        stats := sqlDB.Stats()
                        h.logger.Printf("Database Handler (%s): Drain timeout reached with %d open connections", h.Name(), stats.OpenConnections)
                        return fmt.Errorf("timeout waiting for connections to drain after %v, %d connections still open", h.drainTimeout, stats.OpenConnections)</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        stats := sqlDB.Stats()
                        if stats.OpenConnections &lt;= 1 </span><span class="cov0" title="0">{ // Allow 1 connection for basic operations
                                h.logger.Printf("Database Handler (%s): Database prepared for maintenance mode with minimal connections (drained in %v)", h.Name(), time.Since(drainStart))
                                return nil
                        }</span>
                        <span class="cov0" title="0">h.logger.Printf("Database Handler (%s): Still waiting for %d connections to drain", h.Name(), stats.OpenConnections)</span>
                }
        }
}

// OnMaintenanceEnd handles maintenance mode deactivation
func (h *Handler) OnMaintenanceEnd(ctx context.Context) error <span class="cov0" title="0">{
        h.logger.Printf("Database Handler (%s): Maintenance mode disabled - Restoring original database operations", h.Name())

        // Get database connection
        sqlDB, err := h.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                h.SetState(handlers.StateError)
                return fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        // Restore original connection pool settings
        <span class="cov0" title="0">h.settingsMux.RLock()
        originalSettings := h.originalSettings
        h.settingsMux.RUnlock()

        h.logger.Printf("Database Handler (%s): Restoring original settings - MaxIdle: %d, MaxOpen: %d",
                h.Name(), originalSettings.MaxIdleCons, originalSettings.MaxOpenCons)

        sqlDB.SetMaxIdleConns(originalSettings.MaxIdleCons)
        sqlDB.SetMaxOpenConns(originalSettings.MaxOpenCons)
        sqlDB.SetConnMaxLifetime(originalSettings.ConnMaxLifetime)
        sqlDB.SetConnMaxIdleTime(originalSettings.ConnMaxIdleTime)

        h.SetState(handlers.StateNormal)
        h.logger.Printf("Database Handler (%s): Original database operations restored", h.Name())
        return nil</span>
}

// IsHealthy performs database health check
func (h *Handler) IsHealthy() bool <span class="cov0" title="0">{
        // First check the base handler state
        if !h.BaseHandler.IsHealthy() </span><span class="cov0" title="0">{
                return false
        }</span>

        // Perform database ping
        <span class="cov0" title="0">sqlDB, err := h.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Database Handler (%s): Failed to get underlying sql.DB: %v", h.Name(), err)
                return false
        }</span>

        // Ping database with timeout (use 1/10 of drain timeout, min 1 second, max 10 seconds)
        <span class="cov0" title="0">healthTimeout := h.drainTimeout / 10
        if healthTimeout &lt; time.Second </span><span class="cov0" title="0">{
                healthTimeout = time.Second
        }</span> else<span class="cov0" title="0"> if healthTimeout &gt; 10*time.Second </span><span class="cov0" title="0">{
                healthTimeout = 10 * time.Second
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), healthTimeout)
        defer cancel()

        if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Database Handler (%s): Database health check failed: %v", h.Name(), err)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// GetStats returns database connection statistics
func (h *Handler) GetStats() map[string]interface{} <span class="cov0" title="0">{
        stats := make(map[string]interface{})
        stats["handler_name"] = h.Name()
        stats["handler_state"] = h.State().String()
        stats["drain_timeout"] = h.drainTimeout.String()

        sqlDB, err := h.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                stats["error"] = err.Error()
                return stats
        }</span>

        <span class="cov0" title="0">dbStats := sqlDB.Stats()
        stats["max_open_connections"] = dbStats.MaxOpenConnections
        stats["open_connections"] = dbStats.OpenConnections
        stats["in_use"] = dbStats.InUse
        stats["idle"] = dbStats.Idle
        stats["wait_count"] = dbStats.WaitCount
        stats["wait_duration"] = dbStats.WaitDuration.String()
        stats["max_idle_closed"] = dbStats.MaxIdleClosed
        stats["max_idle_time_closed"] = dbStats.MaxIdleTimeClosed
        stats["max_lifetime_closed"] = dbStats.MaxLifetimeClosed

        // Include cached original settings information
        h.settingsMux.RLock()
        originalSettings := h.originalSettings
        h.settingsMux.RUnlock()

        if originalSettings != nil </span><span class="cov0" title="0">{
                stats["cached_original_settings"] = map[string]interface{}{
                        "max_idle_conns":     originalSettings.MaxIdleCons,
                        "max_open_conns":     originalSettings.MaxOpenCons,
                        "conn_max_lifetime":  originalSettings.ConnMaxLifetime.String(),
                        "conn_max_idle_time": originalSettings.ConnMaxIdleTime.String(),
                }
        }</span> else<span class="cov0" title="0"> {
                stats["cached_original_settings"] = nil
        }</span>

        <span class="cov0" title="0">return stats</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package grpc

import (
        "context"
        "net"
        "sync"
        "sync/atomic"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"
        "google.golang.org/grpc/reflection"

        "github.com/abhishekvarshney/gomaint/pkg/handlers"
)

// Handler handles gRPC server maintenance mode
type Handler struct {
        *handlers.BaseHandler
        server        *grpc.Server
        listener      net.Listener
        healthServer  *health.Server
        drainTimeout  time.Duration
        inMaintenance int32 // atomic boolean
        wg            sync.WaitGroup
}

// NewGRPCHandler creates a new gRPC handler
func NewGRPCHandler(listener net.Listener, drainTimeout time.Duration) *Handler <span class="cov0" title="0">{
        server := grpc.NewServer(
                grpc.UnaryInterceptor(nil),  // Will be set in wrapUnaryInterceptor
                grpc.StreamInterceptor(nil), // Will be set in wrapStreamInterceptor
        )

        // Create health server
        healthServer := health.NewServer()
        grpc_health_v1.RegisterHealthServer(server, healthServer)

        // Register reflection service for debugging
        reflection.Register(server)

        h := &amp;Handler{
                BaseHandler:  handlers.NewBaseHandler("grpc"),
                server:       server,
                listener:     listener,
                healthServer: healthServer,
                drainTimeout: drainTimeout,
        }

        // Set up interceptors after handler is created
        h.setupInterceptors()

        // Set initial health status
        h.healthServer.SetServingStatus("", grpc_health_v1.HealthCheckResponse_SERVING)

        return h
}</span>

// NewHandler creates a new gRPC handler (deprecated: use NewGRPCHandler)
func NewHandler(listener net.Listener, drainTimeout time.Duration) *Handler <span class="cov0" title="0">{
        return NewGRPCHandler(listener, drainTimeout)
}</span>

// GetServer returns the gRPC server instance for service registration
func (h *Handler) GetServer() *grpc.Server <span class="cov0" title="0">{
        return h.server
}</span>

// setupInterceptors configures the gRPC interceptors for maintenance mode handling
func (h *Handler) setupInterceptors() <span class="cov0" title="0">{
        // Create new server with interceptors
        newServer := grpc.NewServer(
                grpc.UnaryInterceptor(h.wrapUnaryInterceptor),
                grpc.StreamInterceptor(h.wrapStreamInterceptor),
        )

        // Re-register health server
        grpc_health_v1.RegisterHealthServer(newServer, h.healthServer)
        reflection.Register(newServer)

        h.server = newServer
}</span>

// OnMaintenanceStart puts the gRPC server into maintenance mode
func (h *Handler) OnMaintenanceStart(ctx context.Context) error <span class="cov0" title="0">{
        atomic.StoreInt32(&amp;h.inMaintenance, 1)
        h.SetState(handlers.StateMaintenance)

        // Update health status to not serving
        h.healthServer.SetServingStatus("", grpc_health_v1.HealthCheckResponse_NOT_SERVING)

        // Wait for active requests to complete or timeout
        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                h.wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                return nil</span>
        case &lt;-time.After(h.drainTimeout):<span class="cov0" title="0">
                return handlers.ErrDrainTimeout</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}

// OnMaintenanceEnd takes the gRPC server out of maintenance mode
func (h *Handler) OnMaintenanceEnd(ctx context.Context) error <span class="cov0" title="0">{
        atomic.StoreInt32(&amp;h.inMaintenance, 0)
        h.SetState(handlers.StateNormal)

        // Update health status to serving
        h.healthServer.SetServingStatus("", grpc_health_v1.HealthCheckResponse_SERVING)

        return nil
}</span>

// wrapUnaryInterceptor wraps unary RPC calls to implement maintenance mode logic
func (h *Handler) wrapUnaryInterceptor(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
) (interface{}, error) <span class="cov0" title="0">{
        // Skip maintenance mode logic for health checks
        if info.FullMethod == "/grpc.health.v1.Health/Check" ||
                info.FullMethod == "/grpc.health.v1.Health/Watch" </span><span class="cov0" title="0">{
                return handler(ctx, req)
        }</span>

        // Check if in maintenance mode
        <span class="cov0" title="0">if atomic.LoadInt32(&amp;h.inMaintenance) == 1 </span><span class="cov0" title="0">{
                return nil, handlers.ErrMaintenanceMode
        }</span>

        // Track active requests for graceful draining
        <span class="cov0" title="0">h.wg.Add(1)
        defer h.wg.Done()

        // Call original handler
        return handler(ctx, req)</span>
}

// wrapStreamInterceptor wraps streaming RPC calls to implement maintenance mode logic
func (h *Handler) wrapStreamInterceptor(
        srv interface{},
        stream grpc.ServerStream,
        info *grpc.StreamServerInfo,
        handler grpc.StreamHandler,
) error <span class="cov0" title="0">{
        // Skip maintenance mode logic for health checks
        if info.FullMethod == "/grpc.health.v1.Health/Watch" </span><span class="cov0" title="0">{
                return handler(srv, stream)
        }</span>

        // Check if in maintenance mode
        <span class="cov0" title="0">if atomic.LoadInt32(&amp;h.inMaintenance) == 1 </span><span class="cov0" title="0">{
                return handlers.ErrMaintenanceMode
        }</span>

        // Track active streams for graceful draining
        <span class="cov0" title="0">h.wg.Add(1)
        defer h.wg.Done()

        // Call original handler
        return handler(srv, stream)</span>
}

// Start starts the gRPC server
func (h *Handler) Start(ctx context.Context) error <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                if err := h.server.Serve(h.listener); err != nil </span><span class="cov0" title="0">{
                        h.Logger().Errorf("gRPC server serve error: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">h.Logger().Infof("gRPC server started on %s", h.listener.Addr().String())
        return nil</span>
}

// Stop gracefully stops the gRPC server
func (h *Handler) Stop(ctx context.Context) error <span class="cov0" title="0">{
        if h.server == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Set health status to not serving
        <span class="cov0" title="0">h.healthServer.SetServingStatus("", grpc_health_v1.HealthCheckResponse_NOT_SERVING)

        // Use graceful stop with context timeout
        stopped := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                h.server.GracefulStop()
                close(stopped)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-stopped:<span class="cov0" title="0">
                h.Logger().Info("gRPC server stopped gracefully")
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                h.Logger().Warn("gRPC server graceful stop timeout, forcing stop")
                h.server.Stop()
                return ctx.Err()</span>
        }
}

// IsInMaintenance returns true if the handler is in maintenance mode
func (h *Handler) IsInMaintenance() bool <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;h.inMaintenance) == 1
}</span>

// GetActiveRequestCount returns the number of active requests
func (h *Handler) GetActiveRequestCount() int <span class="cov0" title="0">{
        // This is an approximation - we can't directly count WaitGroup members
        // In a production system, you might want to implement a proper counter
        if h.IsInMaintenance() </span><span class="cov0" title="0">{
                return 0 // When in maintenance, we're draining
        }</span>
        <span class="cov0" title="0">return 1</span> // Simplified for demo purposes
}

// GetStats returns handler statistics
func (h *Handler) GetStats() map[string]interface{} <span class="cov0" title="0">{
        addr := "unknown"
        if h.listener != nil </span><span class="cov0" title="0">{
                addr = h.listener.Addr().String()
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "handler_name":   h.Name(),
                "handler_state":  h.State().String(),
                "in_maintenance": h.IsInMaintenance(),
                "drain_timeout":  h.drainTimeout.String(),
                "server_addr":    addr,
                "health_status":  h.getHealthStatus(),
        }</span>
}

// getHealthStatus returns the current health status
func (h *Handler) getHealthStatus() string <span class="cov0" title="0">{
        if h.IsInMaintenance() </span><span class="cov0" title="0">{
                return "NOT_SERVING"
        }</span>
        <span class="cov0" title="0">return "SERVING"</span>
}

// GetHealthServer returns the health server for external health checks
func (h *Handler) GetHealthServer() *health.Server <span class="cov0" title="0">{
        return h.healthServer
}</span>

// SetServiceHealth sets the health status for a specific service
func (h *Handler) SetServiceHealth(service string, serving bool) <span class="cov0" title="0">{
        status := grpc_health_v1.HealthCheckResponse_SERVING
        if !serving </span><span class="cov0" title="0">{
                status = grpc_health_v1.HealthCheckResponse_NOT_SERVING
        }</span>
        <span class="cov0" title="0">h.healthServer.SetServingStatus(service, status)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "context"
        "errors"

        "github.com/abhishekvarshney/gomaint/pkg/logger"
)

// Common errors
var (
        ErrMaintenanceMode = errors.New("service is in maintenance mode")
        ErrDrainTimeout    = errors.New("timeout waiting for requests to drain")
)

// Handler defines the interface that all maintenance handlers must implement
type Handler interface {
        // OnMaintenanceStart is called when the service enters maintenance mode
        OnMaintenanceStart(ctx context.Context) error

        // OnMaintenanceEnd is called when the service exits maintenance mode
        OnMaintenanceEnd(ctx context.Context) error

        // Name returns the name of the handler for identification
        Name() string

        // IsHealthy returns true if the handler is in a healthy state
        IsHealthy() bool
}

// HandlerState represents the current state of a handler
type HandlerState int

const (
        StateNormal HandlerState = iota
        StateMaintenance
        StateError
)

func (s HandlerState) String() string <span class="cov0" title="0">{
        switch s </span>{
        case StateNormal:<span class="cov0" title="0">
                return "normal"</span>
        case StateMaintenance:<span class="cov0" title="0">
                return "maintenance"</span>
        case StateError:<span class="cov0" title="0">
                return "error"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// BaseHandler provides common functionality for handlers
type BaseHandler struct {
        name   string
        state  HandlerState
        logger logger.Logger
}

// NewBaseHandler creates a new base handler
func NewBaseHandler(name string) *BaseHandler <span class="cov0" title="0">{
        return &amp;BaseHandler{
                name:   name,
                state:  StateNormal,
                logger: logger.NewDefaultLogger(),
        }
}</span>

// Name returns the handler name
func (h *BaseHandler) Name() string <span class="cov0" title="0">{
        return h.name
}</span>

// State returns the current handler state
func (h *BaseHandler) State() HandlerState <span class="cov0" title="0">{
        return h.state
}</span>

// SetState sets the handler state
func (h *BaseHandler) SetState(state HandlerState) <span class="cov0" title="0">{
        h.state = state
}</span>

// IsHealthy returns true if the handler is not in error state
func (h *BaseHandler) IsHealthy() bool <span class="cov0" title="0">{
        return h.state != StateError
}</span>

// Logger returns the logger instance
func (h *BaseHandler) Logger() logger.Logger <span class="cov0" title="0">{
        return h.logger
}</span>

// SetLogger sets a custom logger
func (h *BaseHandler) SetLogger(l logger.Logger) <span class="cov0" title="0">{
        h.logger = l
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package http

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "sync/atomic"
        "time"

        "github.com/abhishekvarshney/gomaint/pkg/handlers"
        "github.com/abhishekvarshney/gomaint/pkg/set"
)

// Handler handles HTTP server maintenance mode
type Handler struct {
        *handlers.BaseHandler
        server          *http.Server
        skipPaths       *set.Set
        originalHandler http.Handler
        drainTimeout    time.Duration
        inMaintenance   int32 // atomic boolean
        wg              sync.WaitGroup
}

// NewHTTPHandler creates a new HTTP handler
func NewHTTPHandler(server *http.Server, drainTimeout time.Duration) *Handler <span class="cov0" title="0">{
        h := &amp;Handler{
                BaseHandler:     handlers.NewBaseHandler("http"),
                server:          server,
                skipPaths:       set.NewSet(),
                originalHandler: server.Handler,
                drainTimeout:    drainTimeout,
        }

        // Wrap the original handler to track requests
        server.Handler = h.wrapHandler(server.Handler)

        return h
}</span>

// NewHandler creates a new HTTP handler (deprecated: use NewHTTPHandler)
func NewHandler(server *http.Server, drainTimeout time.Duration) *Handler <span class="cov0" title="0">{
        return NewHTTPHandler(server, drainTimeout)
}</span>

func (h *Handler) SkipPaths(paths ...interface{}) <span class="cov0" title="0">{
        h.skipPaths.Add(paths...)
}</span>

// OnMaintenanceStart puts the HTTP server into maintenance mode
func (h *Handler) OnMaintenanceStart(ctx context.Context) error <span class="cov0" title="0">{
        atomic.StoreInt32(&amp;h.inMaintenance, 1)
        h.SetState(handlers.StateMaintenance)

        // Wait for active requests to complete or timeout
        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                h.wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                return nil</span>
        case &lt;-time.After(h.drainTimeout):<span class="cov0" title="0">
                return fmt.Errorf("timeout waiting for requests to drain")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}

// OnMaintenanceEnd takes the HTTP server out of maintenance mode
func (h *Handler) OnMaintenanceEnd(ctx context.Context) error <span class="cov0" title="0">{
        atomic.StoreInt32(&amp;h.inMaintenance, 0)
        h.SetState(handlers.StateNormal)
        return nil
}</span>

// wrapHandler wraps the original handler to implement maintenance mode logic
func (h *Handler) wrapHandler(original http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Skip maintenance mode logic for health check requests
                if h.skipPaths.Contains(r.URL.Path) </span><span class="cov0" title="0">{
                        if original != nil </span><span class="cov0" title="0">{
                                original.ServeHTTP(w, r)
                        }</span> else<span class="cov0" title="0"> {
                                http.NotFound(w, r)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                // Check if in maintenance mode
                <span class="cov0" title="0">if atomic.LoadInt32(&amp;h.inMaintenance) == 1 </span><span class="cov0" title="0">{
                        h.writeMaintenanceResponse(w, r)
                        return
                }</span>

                // Track active requests for graceful draining
                <span class="cov0" title="0">h.wg.Add(1)
                defer h.wg.Done()

                // Call original handler
                if original != nil </span><span class="cov0" title="0">{
                        original.ServeHTTP(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.NotFound(w, r)
                }</span>
        })
}

// writeMaintenanceResponse writes a maintenance mode response
func (h *Handler) writeMaintenanceResponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        // Set Retry-After based on drain timeout (converted to seconds)
        retryAfter := int(h.drainTimeout.Seconds())
        if retryAfter &lt; 1 </span><span class="cov0" title="0">{
                retryAfter = 1
        }</span>
        <span class="cov0" title="0">w.Header().Set("Retry-After", fmt.Sprintf("%d", retryAfter))
        w.WriteHeader(http.StatusServiceUnavailable)

        response := `{
                "error": "Service Unavailable",
                "message": "Service is currently under maintenance. Please try again later.",
                "code": 503
        }`

        w.Write([]byte(response))</span>
}

// IsInMaintenance returns true if the handler is in maintenance mode
func (h *Handler) IsInMaintenance() bool <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;h.inMaintenance) == 1
}</span>

// GetActiveRequestCount returns the number of active requests
func (h *Handler) GetActiveRequestCount() int <span class="cov0" title="0">{
        // This is a simple approximation - in production you might want a more accurate counter
        return int(atomic.LoadInt32(&amp;h.inMaintenance))
}</span>

// GetStats returns handler statistics
func (h *Handler) GetStats() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "handler_name":   h.Name(),
                "handler_state":  h.State().String(),
                "in_maintenance": atomic.LoadInt32(&amp;h.inMaintenance) == 1,
                "drain_timeout":  h.drainTimeout.String(),
                "server_addr":    h.server.Addr,
        }
}</span>

// Shutdown gracefully shuts down the HTTP server
func (h *Handler) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        if h.server == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return h.server.Shutdown(ctx)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package kafka

import (
        "context"
        "fmt"
        "log"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/IBM/sarama"
        "github.com/abhishekvarshney/gomaint/pkg/handlers"
)

// KafkaClient interface allows for easier testing and mocking
type KafkaClient interface {
        sarama.Client
}

// MessageProcessor defines the interface for processing Kafka messages
type MessageProcessor interface {
        ProcessMessage(ctx context.Context, message *sarama.ConsumerMessage) error
}

// Config holds the configuration for the Kafka handler
type Config struct {
        Brokers           []string
        Topics            []string
        ConsumerGroup     string
        BatchSize         int
        SessionTimeout    time.Duration
        HeartbeatInterval time.Duration
        DrainTimeout      time.Duration
        MaxProcessingTime time.Duration
        // Consumer configuration
        OffsetInitial      int64 // sarama.OffsetOldest or sarama.OffsetNewest
        EnableAutoCommit   bool
        AutoCommitInterval time.Duration
        RetryBackoff       time.Duration
        MaxWorkers         int
}

// DefaultConfig returns a default configuration
func DefaultConfig(brokers []string, topics []string, consumerGroup string) *Config <span class="cov0" title="0">{
        return &amp;Config{
                Brokers:            brokers,
                Topics:             topics,
                ConsumerGroup:      consumerGroup,
                BatchSize:          100,
                SessionTimeout:     30 * time.Second,
                HeartbeatInterval:  3 * time.Second,
                DrainTimeout:       45 * time.Second,
                MaxProcessingTime:  30 * time.Second,
                OffsetInitial:      sarama.OffsetNewest,
                EnableAutoCommit:   false, // Manual commit for better control
                AutoCommitInterval: 1 * time.Second,
                RetryBackoff:       2 * time.Second,
                MaxWorkers:         10,
        }
}</span>

// Handler implements the Handler interface for Kafka message processing
type Handler struct {
        *handlers.BaseHandler
        client        sarama.Client
        consumerGroup sarama.ConsumerGroup
        config        *Config
        processor     MessageProcessor
        logger        *log.Logger

        // State management
        inMaintenance int32 // atomic boolean
        stopChan      chan struct{}
        wg            sync.WaitGroup
        mu            sync.RWMutex
        isRunning     bool
        ctx           context.Context
        cancel        context.CancelFunc

        // Worker pool for message processing
        workerPool chan struct{}

        // Statistics
        stats Stats
}

// Stats holds statistics for the Kafka handler
type Stats struct {
        MessagesReceived  int64
        MessagesProcessed int64
        MessagesFailed    int64
        MessagesInFlight  int64
        LastMessageTime   time.Time
        ProcessingErrors  []string
        ConsumerLag       map[string]map[int32]int64 // topic -&gt; partition -&gt; lag
        mu                sync.RWMutex
}

// ConsumerGroupHandler implements sarama.ConsumerGroupHandler
type ConsumerGroupHandler struct {
        handler *Handler
}

// NewKafkaHandler creates a new Kafka handler
func NewKafkaHandler(brokers []string, config *Config, processor MessageProcessor, logger *log.Logger) (*Handler, error) <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.Default()
        }</span>

        <span class="cov0" title="0">if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig(brokers, []string{"test-topic"}, "gomaint-consumer-group")
        }</span>

        // Create Kafka client configuration
        <span class="cov0" title="0">kafkaConfig := sarama.NewConfig()
        kafkaConfig.Version = sarama.V2_8_0_0
        kafkaConfig.Consumer.Group.Session.Timeout = config.SessionTimeout
        kafkaConfig.Consumer.Group.Heartbeat.Interval = config.HeartbeatInterval
        kafkaConfig.Consumer.Offsets.Initial = config.OffsetInitial
        kafkaConfig.Consumer.Group.Rebalance.Strategy = sarama.BalanceStrategyRoundRobin
        kafkaConfig.Consumer.Return.Errors = true
        kafkaConfig.Consumer.Offsets.AutoCommit.Enable = config.EnableAutoCommit
        kafkaConfig.Consumer.Offsets.AutoCommit.Interval = config.AutoCommitInterval
        kafkaConfig.Consumer.Fetch.Default = 1024 * 1024 // 1MB
        kafkaConfig.Consumer.MaxProcessingTime = config.MaxProcessingTime

        // Create Kafka client
        client, err := sarama.NewClient(config.Brokers, kafkaConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Kafka client: %w", err)
        }</span>

        // Create consumer group
        <span class="cov0" title="0">consumerGroup, err := sarama.NewConsumerGroupFromClient(config.ConsumerGroup, client)
        if err != nil </span><span class="cov0" title="0">{
                client.Close()
                return nil, fmt.Errorf("failed to create consumer group: %w", err)
        }</span>

        <span class="cov0" title="0">handler := &amp;Handler{
                BaseHandler:   handlers.NewBaseHandler("kafka"),
                client:        client,
                consumerGroup: consumerGroup,
                config:        config,
                processor:     processor,
                logger:        logger,
                stopChan:      make(chan struct{}),
                workerPool:    make(chan struct{}, config.MaxWorkers),
                stats: Stats{
                        ConsumerLag: make(map[string]map[int32]int64),
                },
        }

        return handler, nil</span>
}

// Start begins message processing (non-blocking)
func (h *Handler) Start(ctx context.Context) error <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if h.isRunning </span><span class="cov0" title="0">{
                h.logger.Println("Kafka Handler: Already running, skipping start")
                return nil
        }</span>

        <span class="cov0" title="0">h.logger.Printf("Kafka Handler: Starting message processing for topics: %v", h.config.Topics)

        // Create a new context for the handler that's independent of the passed context
        h.ctx, h.cancel = context.WithCancel(context.Background())

        // Create a new stop channel if needed
        if h.stopChan == nil </span><span class="cov0" title="0">{
                h.stopChan = make(chan struct{})
        }</span>

        // Start the consumer group
        <span class="cov0" title="0">h.wg.Add(1)
        h.isRunning = true
        go h.consumerLoop(h.ctx)

        return nil</span>
}

// Stop stops message processing
func (h *Handler) Stop() error <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if !h.isRunning </span><span class="cov0" title="0">{
                h.logger.Println("Kafka Handler: Not running, skipping stop")
                return nil
        }</span>

        <span class="cov0" title="0">h.logger.Println("Kafka Handler: Stopping message processing")

        // Cancel the handler context
        if h.cancel != nil </span><span class="cov0" title="0">{
                h.cancel()
        }</span>

        <span class="cov0" title="0">close(h.stopChan)
        h.isRunning = false

        // Wait for consumer loop to finish (unlock mutex first)
        h.mu.Unlock()
        h.wg.Wait()
        h.mu.Lock()

        // Reset stop channel for potential restart
        h.stopChan = nil
        h.ctx = nil
        h.cancel = nil

        h.logger.Println("Kafka Handler: Message processing stopped")
        return nil</span>
}

// OnMaintenanceStart handles maintenance mode activation
func (h *Handler) OnMaintenanceStart(ctx context.Context) error <span class="cov0" title="0">{
        h.logger.Println("Kafka Handler: Entering maintenance mode - draining messages")
        atomic.StoreInt32(&amp;h.inMaintenance, 1)
        h.SetState(handlers.StateMaintenance)

        // Stop the handler to prevent new messages from being received
        if err := h.Stop(); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Kafka Handler: Error stopping during maintenance: %v", err)
        }</span>

        // Wait for in-flight messages to complete or timeout
        <span class="cov0" title="0">done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                h.wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                h.logger.Println("Kafka Handler: All messages drained successfully")
                return nil</span>
        case &lt;-time.After(h.config.DrainTimeout):<span class="cov0" title="0">
                inFlight := atomic.LoadInt64(&amp;h.stats.MessagesInFlight)
                h.logger.Printf("Kafka Handler: Drain timeout reached with %d messages still in flight", inFlight)
                return fmt.Errorf("timeout waiting for %d messages to drain after %v", inFlight, h.config.DrainTimeout)</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}

// OnMaintenanceEnd handles maintenance mode deactivation
func (h *Handler) OnMaintenanceEnd(ctx context.Context) error <span class="cov0" title="0">{
        h.logger.Println("Kafka Handler: Exiting maintenance mode - resuming message processing")
        atomic.StoreInt32(&amp;h.inMaintenance, 0)
        h.SetState(handlers.StateNormal)

        // Restart the handler if it was running
        h.mu.Lock()
        wasRunning := h.isRunning
        h.mu.Unlock()

        if !wasRunning </span><span class="cov0" title="0">{
                // Start the handler with a fresh context
                if err := h.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        h.logger.Printf("Kafka Handler: Failed to restart after maintenance: %v", err)
                        return err
                }</span>
                <span class="cov0" title="0">h.logger.Println("Kafka Handler: Message processing resumed after maintenance")</span>
        } else<span class="cov0" title="0"> {
                h.logger.Println("Kafka Handler: Message processing will continue automatically")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsHealthy performs Kafka health check
func (h *Handler) IsHealthy() bool <span class="cov0" title="0">{
        // First check the base handler state
        if !h.BaseHandler.IsHealthy() </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check Kafka client connectivity
        <span class="cov0" title="0">if h.client == nil || h.client.Closed() </span><span class="cov0" title="0">{
                h.logger.Println("Kafka Handler: Health check failed - client is closed")
                return false
        }</span>

        // Check if we can get broker list
        <span class="cov0" title="0">brokers := h.client.Brokers()
        if len(brokers) == 0 </span><span class="cov0" title="0">{
                h.logger.Println("Kafka Handler: Health check failed - no brokers available")
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// GetStats returns handler statistics
func (h *Handler) GetStats() map[string]interface{} <span class="cov0" title="0">{
        h.stats.mu.RLock()
        defer h.stats.mu.RUnlock()

        stats := map[string]interface{}{
                "handler_name":       h.Name(),
                "handler_state":      h.State().String(),
                "topics":             h.config.Topics,
                "consumer_group":     h.config.ConsumerGroup,
                "brokers":            h.config.Brokers,
                "in_maintenance":     atomic.LoadInt32(&amp;h.inMaintenance) == 1,
                "messages_received":  h.stats.MessagesReceived,
                "messages_processed": h.stats.MessagesProcessed,
                "messages_failed":    h.stats.MessagesFailed,
                "messages_in_flight": h.stats.MessagesInFlight,
                "last_message_time":  h.stats.LastMessageTime,
                "drain_timeout":      h.config.DrainTimeout.String(),
                "max_workers":        h.config.MaxWorkers,
                "consumer_lag":       h.stats.ConsumerLag,
        }

        // Include recent errors if any
        if len(h.stats.ProcessingErrors) &gt; 0 </span><span class="cov0" title="0">{
                // Show last 5 errors
                errorCount := len(h.stats.ProcessingErrors)
                startIdx := 0
                if errorCount &gt; 5 </span><span class="cov0" title="0">{
                        startIdx = errorCount - 5
                }</span>
                <span class="cov0" title="0">stats["recent_errors"] = h.stats.ProcessingErrors[startIdx:]</span>
        }

        <span class="cov0" title="0">return stats</span>
}

// consumerLoop is the main consumer group loop
func (h *Handler) consumerLoop(ctx context.Context) <span class="cov0" title="0">{
        defer h.wg.Done()
        defer func() </span><span class="cov0" title="0">{
                h.mu.Lock()
                h.isRunning = false
                h.mu.Unlock()
        }</span>()

        <span class="cov0" title="0">h.logger.Println("Kafka Handler: Consumer loop started")

        groupHandler := &amp;ConsumerGroupHandler{handler: h}

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        h.logger.Println("Kafka Handler: Context cancelled, stopping consumer loop")
                        return</span>
                case &lt;-h.stopChan:<span class="cov0" title="0">
                        h.logger.Println("Kafka Handler: Stop signal received, stopping consumer loop")
                        return</span>
                case err := &lt;-h.consumerGroup.Errors():<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                h.logger.Printf("Kafka Handler: Consumer group error: %v", err)
                                h.addProcessingError(err.Error())
                        }</span>
                default:<span class="cov0" title="0">
                        // Skip consuming new messages if in maintenance mode
                        if atomic.LoadInt32(&amp;h.inMaintenance) == 1 </span><span class="cov0" title="0">{
                                time.Sleep(100 * time.Millisecond)
                                continue</span>
                        }

                        // Consume messages from topics
                        <span class="cov0" title="0">err := h.consumerGroup.Consume(ctx, h.config.Topics, groupHandler)
                        if err != nil </span><span class="cov0" title="0">{
                                h.logger.Printf("Kafka Handler: Error consuming messages: %v", err)
                                h.addProcessingError(err.Error())

                                // Retry after backoff
                                select </span>{
                                case &lt;-time.After(h.config.RetryBackoff):<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                case &lt;-h.stopChan:<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }
        }
}

// Setup is run at the beginning of a new session, before ConsumeClaim
func (cgh *ConsumerGroupHandler) Setup(sarama.ConsumerGroupSession) error <span class="cov0" title="0">{
        cgh.handler.logger.Println("Kafka Handler: Consumer group session setup")
        return nil
}</span>

// Cleanup is run at the end of a session, once all ConsumeClaim goroutines have exited
func (cgh *ConsumerGroupHandler) Cleanup(sarama.ConsumerGroupSession) error <span class="cov0" title="0">{
        cgh.handler.logger.Println("Kafka Handler: Consumer group session cleanup")
        return nil
}</span>

// ConsumeClaim must start a consumer loop of ConsumerGroupClaim's Messages()
func (cgh *ConsumerGroupHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error <span class="cov0" title="0">{
        // NOTE: Do not move the code below to a goroutine.
        // The `ConsumeClaim` itself is called within a goroutine
        for </span><span class="cov0" title="0">{
                select </span>{
                case message := &lt;-claim.Messages():<span class="cov0" title="0">
                        if message == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        // Track message reception
                        <span class="cov0" title="0">atomic.AddInt64(&amp;cgh.handler.stats.MessagesReceived, 1)
                        atomic.AddInt64(&amp;cgh.handler.stats.MessagesInFlight, 1)

                        cgh.handler.stats.mu.Lock()
                        cgh.handler.stats.LastMessageTime = time.Now()
                        cgh.handler.stats.mu.Unlock()

                        // Acquire worker slot (blocks if all workers are busy)
                        cgh.handler.workerPool &lt;- struct{}{}

                        // Process message in goroutine
                        cgh.handler.wg.Add(1)
                        go cgh.handler.processMessage(session, message)</span>

                // Should return when `session.Context()` is done.
                // If not, will raise `ErrRebalanceInProgress` or `ErrNotCoordinatorForConsumer` error.
                case &lt;-session.Context().Done():<span class="cov0" title="0">
                        return nil</span>
                }
        }
}

// processMessage processes a single message
func (h *Handler) processMessage(session sarama.ConsumerGroupSession, message *sarama.ConsumerMessage) <span class="cov0" title="0">{
        defer h.wg.Done()
        defer atomic.AddInt64(&amp;h.stats.MessagesInFlight, -1)
        defer func() </span><span class="cov0" title="0">{ &lt;-h.workerPool }</span>() // Release worker slot

        // Process the message
        <span class="cov0" title="0">if err := h.processor.ProcessMessage(session.Context(), message); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("Kafka Handler: Failed to process message from topic %s partition %d offset %d: %v",
                        message.Topic, message.Partition, message.Offset, err)
                atomic.AddInt64(&amp;h.stats.MessagesFailed, 1)
                h.addProcessingError(fmt.Sprintf("Topic %s Partition %d Offset %d: %v",
                        message.Topic, message.Partition, message.Offset, err))
                return
        }</span>

        // Mark message as processed
        <span class="cov0" title="0">session.MarkMessage(message, "")

        // Commit the offset if auto-commit is disabled
        if !h.config.EnableAutoCommit </span><span class="cov0" title="0">{
                session.Commit()
        }</span>

        <span class="cov0" title="0">atomic.AddInt64(&amp;h.stats.MessagesProcessed, 1)
        h.logger.Printf("Kafka Handler: Successfully processed message from topic %s partition %d offset %d",
                message.Topic, message.Partition, message.Offset)</span>
}

// addProcessingError adds an error to the processing errors list (keeps last 10)
func (h *Handler) addProcessingError(errorMsg string) <span class="cov0" title="0">{
        h.stats.mu.Lock()
        defer h.stats.mu.Unlock()

        h.stats.ProcessingErrors = append(h.stats.ProcessingErrors,
                fmt.Sprintf("%s: %s", time.Now().Format(time.RFC3339), errorMsg))

        // Keep only last 10 errors
        if len(h.stats.ProcessingErrors) &gt; 10 </span><span class="cov0" title="0">{
                h.stats.ProcessingErrors = h.stats.ProcessingErrors[1:]
        }</span>
}

// Close closes the handler and releases resources
func (h *Handler) Close() error <span class="cov0" title="0">{
        h.Stop()

        var errs []string

        if h.consumerGroup != nil </span><span class="cov0" title="0">{
                if err := h.consumerGroup.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("consumer group close error: %v", err))
                }</span>
        }

        <span class="cov0" title="0">if h.client != nil </span><span class="cov0" title="0">{
                if err := h.client.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("client close error: %v", err))
                }</span>
        }

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("kafka handler close errors: %s", strings.Join(errs, "; "))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetTopicMetadata returns metadata about the configured topics
func (h *Handler) GetTopicMetadata() (map[string]interface{}, error) <span class="cov0" title="0">{
        if h.client == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("client is not initialized")
        }</span>

        <span class="cov0" title="0">metadata := make(map[string]interface{})

        for _, topic := range h.config.Topics </span><span class="cov0" title="0">{
                partitions, err := h.client.Partitions(topic)
                if err != nil </span><span class="cov0" title="0">{
                        metadata[topic] = map[string]interface{}{
                                "error": err.Error(),
                        }
                        continue</span>
                }

                <span class="cov0" title="0">topicInfo := map[string]interface{}{
                        "partitions":     len(partitions),
                        "partition_list": partitions,
                }

                metadata[topic] = topicInfo</span>
        }

        <span class="cov0" title="0">return metadata, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package sqs

import (
        "context"
        "fmt"
        "log"
        "sync"
        "sync/atomic"
        "time"

        "github.com/abhishekvarshney/gomaint/pkg/handlers"
        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sqs"
        "github.com/aws/aws-sdk-go-v2/service/sqs/types"
)

// SQSClient interface allows for easier testing and mocking
type SQSClient interface {
        ReceiveMessage(ctx context.Context, params *sqs.ReceiveMessageInput, optFns ...func(*sqs.Options)) (*sqs.ReceiveMessageOutput, error)
        DeleteMessage(ctx context.Context, params *sqs.DeleteMessageInput, optFns ...func(*sqs.Options)) (*sqs.DeleteMessageOutput, error)
        GetQueueAttributes(ctx context.Context, params *sqs.GetQueueAttributesInput, optFns ...func(*sqs.Options)) (*sqs.GetQueueAttributesOutput, error)
}

// MessageProcessor defines the interface for processing SQS messages
type MessageProcessor interface {
        ProcessMessage(ctx context.Context, message types.Message) error
}

// Config holds the configuration for the SQS handler
type Config struct {
        QueueURL                 string
        MaxNumberOfMessages      int32
        WaitTimeSeconds          int32
        VisibilityTimeoutSeconds int32
        DrainTimeout             time.Duration
        PollInterval             time.Duration
}

// DefaultConfig returns a default configuration
func DefaultConfig(queueURL string) *Config <span class="cov0" title="0">{
        return &amp;Config{
                QueueURL:                 queueURL,
                MaxNumberOfMessages:      10,
                WaitTimeSeconds:          20,
                VisibilityTimeoutSeconds: 30,
                DrainTimeout:             30 * time.Second,
                PollInterval:             1 * time.Second,
        }
}</span>

// Handler implements the Handler interface for SQS message processing
type Handler struct {
        *handlers.BaseHandler
        client    SQSClient
        config    *Config
        processor MessageProcessor
        logger    *log.Logger

        // State management
        inMaintenance int32 // atomic boolean
        stopChan      chan struct{}
        wg            sync.WaitGroup
        mu            sync.RWMutex
        isRunning     bool
        ctx           context.Context
        cancel        context.CancelFunc

        // Statistics
        stats Stats
}

// Stats holds statistics for the SQS handler
type Stats struct {
        MessagesReceived  int64
        MessagesProcessed int64
        MessagesFailed    int64
        MessagesInFlight  int64
        LastMessageTime   time.Time
        ProcessingErrors  []string
        mu                sync.RWMutex
}

// NewSQSHandler creates a new SQS handler
func NewSQSHandler(client SQSClient, config *Config, processor MessageProcessor, logger *log.Logger) *Handler <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.Default()
        }</span>

        <span class="cov0" title="0">return &amp;Handler{
                BaseHandler: handlers.NewBaseHandler("sqs"),
                client:      client,
                config:      config,
                processor:   processor,
                logger:      logger,
                stopChan:    make(chan struct{}),
        }</span>
}

// Start begins message processing (non-blocking)
func (h *Handler) Start(ctx context.Context) error <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if h.isRunning </span><span class="cov0" title="0">{
                h.logger.Println("SQS Handler: Already running, skipping start")
                return nil
        }</span>

        <span class="cov0" title="0">h.logger.Printf("SQS Handler: Starting message processing for queue: %s", h.config.QueueURL)

        // Create a new context for the handler that's independent of the passed context
        h.ctx, h.cancel = context.WithCancel(context.Background())

        // Create a new stop channel if needed
        if h.stopChan == nil </span><span class="cov0" title="0">{
                h.stopChan = make(chan struct{})
        }</span>

        // Start the message processing goroutine
        <span class="cov0" title="0">h.wg.Add(1)
        h.isRunning = true
        go h.messageLoop(h.ctx)

        return nil</span>
}

// Stop stops message processing
func (h *Handler) Stop() error <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if !h.isRunning </span><span class="cov0" title="0">{
                h.logger.Println("SQS Handler: Not running, skipping stop")
                return nil
        }</span>

        <span class="cov0" title="0">h.logger.Println("SQS Handler: Stopping message processing")

        // Cancel the handler context
        if h.cancel != nil </span><span class="cov0" title="0">{
                h.cancel()
        }</span>

        <span class="cov0" title="0">close(h.stopChan)
        h.isRunning = false

        // Wait for message loop to finish (unlock mutex first)
        h.mu.Unlock()
        h.wg.Wait()
        h.mu.Lock()

        // Reset stop channel for potential restart
        h.stopChan = nil
        h.ctx = nil
        h.cancel = nil

        h.logger.Println("SQS Handler: Message processing stopped")
        return nil</span>
}

// OnMaintenanceStart handles maintenance mode activation
func (h *Handler) OnMaintenanceStart(ctx context.Context) error <span class="cov0" title="0">{
        h.logger.Println("SQS Handler: Entering maintenance mode - draining messages")
        atomic.StoreInt32(&amp;h.inMaintenance, 1)
        h.SetState(handlers.StateMaintenance)

        // Stop the handler to prevent new messages from being received
        if err := h.Stop(); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("SQS Handler: Error stopping during maintenance: %v", err)
        }</span>

        // Wait for in-flight messages to complete or timeout
        <span class="cov0" title="0">done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                h.wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                h.logger.Println("SQS Handler: All messages drained successfully")
                return nil</span>
        case &lt;-time.After(h.config.DrainTimeout):<span class="cov0" title="0">
                inFlight := atomic.LoadInt64(&amp;h.stats.MessagesInFlight)
                h.logger.Printf("SQS Handler: Drain timeout reached with %d messages still in flight", inFlight)
                return fmt.Errorf("timeout waiting for %d messages to drain after %v", inFlight, h.config.DrainTimeout)</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}

// OnMaintenanceEnd handles maintenance mode deactivation
func (h *Handler) OnMaintenanceEnd(ctx context.Context) error <span class="cov0" title="0">{
        h.logger.Println("SQS Handler: Exiting maintenance mode - resuming message processing")
        atomic.StoreInt32(&amp;h.inMaintenance, 0)
        h.SetState(handlers.StateNormal)

        // Restart the handler if it was running
        h.mu.Lock()
        wasRunning := h.isRunning
        h.mu.Unlock()

        if !wasRunning </span><span class="cov0" title="0">{
                // Start the handler with a fresh context
                if err := h.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        h.logger.Printf("SQS Handler: Failed to restart after maintenance: %v", err)
                        return err
                }</span>
                <span class="cov0" title="0">h.logger.Println("SQS Handler: Message processing resumed after maintenance")</span>
        } else<span class="cov0" title="0"> {
                h.logger.Println("SQS Handler: Message processing will continue automatically")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsHealthy performs SQS health check
func (h *Handler) IsHealthy() bool <span class="cov0" title="0">{
        // First check the base handler state
        if !h.BaseHandler.IsHealthy() </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check SQS connectivity by getting queue attributes
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := h.client.GetQueueAttributes(ctx, &amp;sqs.GetQueueAttributesInput{
                QueueUrl: aws.String(h.config.QueueURL),
                AttributeNames: []types.QueueAttributeName{
                        types.QueueAttributeNameApproximateNumberOfMessages,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("SQS Handler: Health check failed: %v", err)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// GetStats returns handler statistics
func (h *Handler) GetStats() map[string]interface{} <span class="cov0" title="0">{
        h.stats.mu.RLock()
        defer h.stats.mu.RUnlock()

        stats := map[string]interface{}{
                "handler_name":       h.Name(),
                "handler_state":      h.State().String(),
                "queue_url":          h.config.QueueURL,
                "in_maintenance":     atomic.LoadInt32(&amp;h.inMaintenance) == 1,
                "messages_received":  h.stats.MessagesReceived,
                "messages_processed": h.stats.MessagesProcessed,
                "messages_failed":    h.stats.MessagesFailed,
                "messages_in_flight": h.stats.MessagesInFlight,
                "last_message_time":  h.stats.LastMessageTime,
                "drain_timeout":      h.config.DrainTimeout.String(),
        }

        // Include recent errors if any
        if len(h.stats.ProcessingErrors) &gt; 0 </span><span class="cov0" title="0">{
                // Show last 5 errors
                errorCount := len(h.stats.ProcessingErrors)
                startIdx := 0
                if errorCount &gt; 5 </span><span class="cov0" title="0">{
                        startIdx = errorCount - 5
                }</span>
                <span class="cov0" title="0">stats["recent_errors"] = h.stats.ProcessingErrors[startIdx:]</span>
        }

        <span class="cov0" title="0">return stats</span>
}

// messageLoop is the main message processing loop
func (h *Handler) messageLoop(ctx context.Context) <span class="cov0" title="0">{
        defer h.wg.Done()
        defer func() </span><span class="cov0" title="0">{
                h.mu.Lock()
                h.isRunning = false
                h.mu.Unlock()
        }</span>()

        <span class="cov0" title="0">ticker := time.NewTicker(h.config.PollInterval)
        defer ticker.Stop()

        h.logger.Println("SQS Handler: Message loop started")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        h.logger.Println("SQS Handler: Context cancelled, stopping message loop")
                        return</span>
                case &lt;-h.stopChan:<span class="cov0" title="0">
                        h.logger.Println("SQS Handler: Stop signal received, stopping message loop")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Skip receiving new messages if in maintenance mode
                        if atomic.LoadInt32(&amp;h.inMaintenance) == 1 </span><span class="cov0" title="0">{
                                // Don't log every poll interval to avoid spam
                                continue</span>
                        }

                        // Receive messages from SQS
                        <span class="cov0" title="0">if err := h.receiveAndProcessMessages(ctx); err != nil </span><span class="cov0" title="0">{
                                h.logger.Printf("SQS Handler: Error receiving messages: %v", err)
                                h.addProcessingError(err.Error())
                        }</span>
                }
        }
}

// receiveAndProcessMessages receives and processes messages from SQS
func (h *Handler) receiveAndProcessMessages(ctx context.Context) error <span class="cov0" title="0">{
        // Receive messages
        result, err := h.client.ReceiveMessage(ctx, &amp;sqs.ReceiveMessageInput{
                QueueUrl:            aws.String(h.config.QueueURL),
                MaxNumberOfMessages: h.config.MaxNumberOfMessages,
                WaitTimeSeconds:     h.config.WaitTimeSeconds,
                VisibilityTimeout:   h.config.VisibilityTimeoutSeconds,
        })

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to receive messages: %w", err)
        }</span>

        // Process each message concurrently
        <span class="cov0" title="0">for _, message := range result.Messages </span><span class="cov0" title="0">{
                // Track message reception
                atomic.AddInt64(&amp;h.stats.MessagesReceived, 1)
                atomic.AddInt64(&amp;h.stats.MessagesInFlight, 1)

                h.stats.mu.Lock()
                h.stats.LastMessageTime = time.Now()
                h.stats.mu.Unlock()

                // Process message in goroutine
                h.wg.Add(1)
                go h.processMessage(ctx, message)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// processMessage processes a single message
func (h *Handler) processMessage(ctx context.Context, message types.Message) <span class="cov0" title="0">{
        defer h.wg.Done()
        defer atomic.AddInt64(&amp;h.stats.MessagesInFlight, -1)

        // Process the message
        if err := h.processor.ProcessMessage(ctx, message); err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("SQS Handler: Failed to process message %s: %v",
                        aws.ToString(message.MessageId), err)
                atomic.AddInt64(&amp;h.stats.MessagesFailed, 1)
                h.addProcessingError(fmt.Sprintf("MessageId %s: %v",
                        aws.ToString(message.MessageId), err))
                return
        }</span>

        // Delete message from queue on successful processing
        <span class="cov0" title="0">_, err := h.client.DeleteMessage(ctx, &amp;sqs.DeleteMessageInput{
                QueueUrl:      aws.String(h.config.QueueURL),
                ReceiptHandle: message.ReceiptHandle,
        })

        if err != nil </span><span class="cov0" title="0">{
                h.logger.Printf("SQS Handler: Failed to delete message %s: %v",
                        aws.ToString(message.MessageId), err)
                h.addProcessingError(fmt.Sprintf("Delete failed for MessageId %s: %v",
                        aws.ToString(message.MessageId), err))
                return
        }</span>

        <span class="cov0" title="0">atomic.AddInt64(&amp;h.stats.MessagesProcessed, 1)
        h.logger.Printf("SQS Handler: Successfully processed message %s",
                aws.ToString(message.MessageId))</span>
}

// addProcessingError adds an error to the processing errors list (keeps last 10)
func (h *Handler) addProcessingError(errorMsg string) <span class="cov0" title="0">{
        h.stats.mu.Lock()
        defer h.stats.mu.Unlock()

        h.stats.ProcessingErrors = append(h.stats.ProcessingErrors,
                fmt.Sprintf("%s: %s", time.Now().Format(time.RFC3339), errorMsg))

        // Keep only last 10 errors
        if len(h.stats.ProcessingErrors) &gt; 10 </span><span class="cov0" title="0">{
                h.stats.ProcessingErrors = h.stats.ProcessingErrors[1:]
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package logger

import "log"

// Logger interface for structured logging across gomaint
type Logger interface {
        Info(args ...interface{})
        Infof(format string, args ...interface{})
        Warn(args ...interface{})
        Warnf(format string, args ...interface{})
        Error(args ...interface{})
        Errorf(format string, args ...interface{})
}

// DefaultLogger implements Logger using standard log package
type DefaultLogger struct{}

// NewDefaultLogger creates a new default logger instance
func NewDefaultLogger() Logger <span class="cov8" title="1">{
        return &amp;DefaultLogger{}
}</span>

// Info logs an info message
func (l *DefaultLogger) Info(args ...interface{}) <span class="cov8" title="1">{
        log.Println(append([]interface{}{"INFO:"}, args...)...)
}</span>

// Infof logs a formatted info message
func (l *DefaultLogger) Infof(format string, args ...interface{}) <span class="cov8" title="1">{
        log.Printf("INFO: "+format, args...)
}</span>

// Warn logs a warning message
func (l *DefaultLogger) Warn(args ...interface{}) <span class="cov8" title="1">{
        log.Println(append([]interface{}{"WARN:"}, args...)...)
}</span>

// Warnf logs a formatted warning message
func (l *DefaultLogger) Warnf(format string, args ...interface{}) <span class="cov8" title="1">{
        log.Printf("WARN: "+format, args...)
}</span>

// Error logs an error message
func (l *DefaultLogger) Error(args ...interface{}) <span class="cov8" title="1">{
        log.Println(append([]interface{}{"ERROR:"}, args...)...)
}</span>

// Errorf logs a formatted error message
func (l *DefaultLogger) Errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        log.Printf("ERROR: "+format, args...)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package maintenance

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/abhishekvarshney/gomaint/pkg/eventsource"
        "github.com/abhishekvarshney/gomaint/pkg/handlers"
)

// Manager coordinates maintenance mode across multiple handlers using a single event source
type Manager struct {
        eventSource    eventsource.EventSource
        handlers       map[string]handlers.Handler
        handlersMux    sync.RWMutex
        inMaintenance  bool
        maintenanceMux sync.RWMutex
        drainTimeout   time.Duration
        ctx            context.Context
        cancel         context.CancelFunc
        started        bool
        startedMux     sync.RWMutex
}

// NewManager creates a new maintenance manager with the specified event source
func NewManager(eventSource eventsource.EventSource, drainTimeout time.Duration) *Manager <span class="cov0" title="0">{
        if drainTimeout &lt;= 0 </span><span class="cov0" title="0">{
                drainTimeout = 30 * time.Second
        }</span>

        <span class="cov0" title="0">return &amp;Manager{
                eventSource:  eventSource,
                handlers:     make(map[string]handlers.Handler),
                drainTimeout: drainTimeout,
        }</span>
}

// RegisterHandler registers a handler with the manager
func (m *Manager) RegisterHandler(handler handlers.Handler) error <span class="cov0" title="0">{
        if handler == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("handler cannot be nil")
        }</span>

        <span class="cov0" title="0">m.handlersMux.Lock()
        defer m.handlersMux.Unlock()

        name := handler.Name()
        if _, exists := m.handlers[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("handler with name '%s' already registered", name)
        }</span>

        <span class="cov0" title="0">m.handlers[name] = handler
        return nil</span>
}

// UnregisterHandler removes a handler from the manager
func (m *Manager) UnregisterHandler(name string) error <span class="cov0" title="0">{
        m.handlersMux.Lock()
        defer m.handlersMux.Unlock()

        if _, exists := m.handlers[name]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("handler with name '%s' not found", name)
        }</span>

        <span class="cov0" title="0">delete(m.handlers, name)
        return nil</span>
}

// GetHandler returns a handler by name
func (m *Manager) GetHandler(name string) (handlers.Handler, bool) <span class="cov0" title="0">{
        m.handlersMux.RLock()
        defer m.handlersMux.RUnlock()

        handler, exists := m.handlers[name]
        return handler, exists
}</span>

// ListHandlers returns a list of all registered handler names
func (m *Manager) ListHandlers() []string <span class="cov0" title="0">{
        m.handlersMux.RLock()
        defer m.handlersMux.RUnlock()

        names := make([]string, 0, len(m.handlers))
        for name := range m.handlers </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// Start begins monitoring for maintenance state changes
func (m *Manager) Start(ctx context.Context) error <span class="cov0" title="0">{
        m.startedMux.Lock()
        defer m.startedMux.Unlock()

        if m.started </span><span class="cov0" title="0">{
                return fmt.Errorf("manager already started")
        }</span>

        <span class="cov0" title="0">if m.eventSource == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event source not configured")
        }</span>

        <span class="cov0" title="0">m.ctx, m.cancel = context.WithCancel(ctx)

        // Start the event source with our handler
        if err := m.eventSource.Start(m.ctx, m.handleMaintenanceEvent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start event source: %w", err)
        }</span>

        <span class="cov0" title="0">m.started = true
        return nil</span>
}

// Stop stops the manager and all handlers
func (m *Manager) Stop() error <span class="cov0" title="0">{
        m.startedMux.Lock()
        defer m.startedMux.Unlock()

        if !m.started </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var lastErr error

        // Cancel context first
        if m.cancel != nil </span><span class="cov0" title="0">{
                m.cancel()
        }</span>

        // Stop the event source
        <span class="cov0" title="0">if m.eventSource != nil </span><span class="cov0" title="0">{
                if err := m.eventSource.Stop(); err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("failed to stop event source: %w", err)
                }</span>
        }

        // If currently in maintenance, try to gracefully exit maintenance mode
        <span class="cov0" title="0">if m.IsInMaintenance() </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), m.drainTimeout)
                defer cancel()

                if err := m.exitMaintenanceMode(ctx); err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("failed to exit maintenance mode: %w", err)
                }</span>
        }

        <span class="cov0" title="0">m.started = false
        return lastErr</span>
}

// IsInMaintenance returns true if the service is currently in maintenance mode
func (m *Manager) IsInMaintenance() bool <span class="cov0" title="0">{
        m.maintenanceMux.RLock()
        defer m.maintenanceMux.RUnlock()
        return m.inMaintenance
}</span>

// SetMaintenance manually sets the maintenance mode (updates the event source)
func (m *Manager) SetMaintenance(ctx context.Context, enabled bool) error <span class="cov0" title="0">{
        if m.eventSource == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event source not configured")
        }</span>

        <span class="cov0" title="0">return m.eventSource.SetMaintenance(ctx, enabled)</span>
}

// GetMaintenance gets the current maintenance mode from the event source
func (m *Manager) GetMaintenance(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        if m.eventSource == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("event source not configured")
        }</span>

        <span class="cov0" title="0">return m.eventSource.GetMaintenance(ctx)</span>
}

// IsHealthy returns true if the event source and all handlers are healthy
func (m *Manager) IsHealthy() bool <span class="cov0" title="0">{
        // Check event source health
        if m.eventSource != nil &amp;&amp; !m.eventSource.IsHealthy() </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check all handlers
        <span class="cov0" title="0">m.handlersMux.RLock()
        defer m.handlersMux.RUnlock()

        for _, handler := range m.handlers </span><span class="cov0" title="0">{
                if !handler.IsHealthy() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// GetEventSource returns the event source for advanced usage
func (m *Manager) GetEventSource() eventsource.EventSource <span class="cov0" title="0">{
        return m.eventSource
}</span>

// GetHandlerHealth returns the health status of all handlers
func (m *Manager) GetHandlerHealth() map[string]bool <span class="cov0" title="0">{
        m.handlersMux.RLock()
        defer m.handlersMux.RUnlock()

        health := make(map[string]bool)
        for name, handler := range m.handlers </span><span class="cov0" title="0">{
                health[name] = handler.IsHealthy()
        }</span>
        <span class="cov0" title="0">return health</span>
}

// WaitForMaintenance waits for the service to enter or exit maintenance mode
func (m *Manager) WaitForMaintenance(ctx context.Context, enabled bool, timeout time.Duration) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        ticker := time.NewTicker(100 * time.Millisecond)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if m.IsInMaintenance() == enabled </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }
}

// handleMaintenanceEvent handles maintenance events from the event source
func (m *Manager) handleMaintenanceEvent(event eventsource.MaintenanceEvent) error <span class="cov0" title="0">{
        enabled := event.Type == eventsource.MaintenanceEnabled

        m.maintenanceMux.Lock()
        currentState := m.inMaintenance
        m.inMaintenance = enabled
        m.maintenanceMux.Unlock()

        // No state change, nothing to do
        if currentState == enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(m.ctx, m.drainTimeout)
        defer cancel()

        if enabled </span><span class="cov0" title="0">{
                return m.enterMaintenanceMode(ctx)
        }</span> else<span class="cov0" title="0"> {
                return m.exitMaintenanceMode(ctx)
        }</span>
}

// enterMaintenanceMode puts all handlers into maintenance mode
func (m *Manager) enterMaintenanceMode(ctx context.Context) error <span class="cov0" title="0">{
        m.handlersMux.RLock()
        defer m.handlersMux.RUnlock()

        var errors []error

        for name, handler := range m.handlers </span><span class="cov0" title="0">{
                if err := handler.OnMaintenanceStart(ctx); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("handler '%s': %w", name, err))
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to enter maintenance mode for some handlers: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// exitMaintenanceMode takes all handlers out of maintenance mode
func (m *Manager) exitMaintenanceMode(ctx context.Context) error <span class="cov0" title="0">{
        m.handlersMux.RLock()
        defer m.handlersMux.RUnlock()

        var errors []error

        for name, handler := range m.handlers </span><span class="cov0" title="0">{
                if err := handler.OnMaintenanceEnd(ctx); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("handler '%s': %w", name, err))
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to exit maintenance mode for some handlers: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package set

// Set represents a collection of unique elements.
type Set struct {
        m map[interface{}]struct{}
}

// NewSet initializes a new set with the given elements.
func NewSet(items ...interface{}) *Set <span class="cov0" title="0">{
        s := &amp;Set{
                m: make(map[interface{}]struct{}),
        }
        s.Add(items...)
        return s
}</span>

// Add inserts elements into the set.
func (s *Set) Add(items ...interface{}) <span class="cov0" title="0">{
        for _, item := range items </span><span class="cov0" title="0">{
                s.m[item] = struct{}{}
        }</span>
}

// Contains checks if an element exists in the set.
func (s *Set) Contains(item interface{}) bool <span class="cov0" title="0">{
        _, found := s.m[item]
        return found
}</span>

// Remove deletes an element from the set.
func (s *Set) Remove(item interface{}) <span class="cov0" title="0">{
        delete(s.m, item)
}</span>

// Size returns the number of elements in the set.
func (s *Set) Size() int <span class="cov0" title="0">{
        return len(s.m)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
